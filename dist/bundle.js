/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@yomguithereal/helpers/extend.js":
/*!*******************************************************!*\
  !*** ./node_modules/@yomguithereal/helpers/extend.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Extend function\n * ================\n *\n * Function used to push a bunch of values into an array at once.\n *\n * Its strategy is to mutate target array's length then setting the new indices\n * to be the values to add.\n *\n * A benchmark proved that it is faster than the following strategies:\n *   1) `array.push.apply(array, values)`.\n *   2) A loop of pushes.\n *   3) `array = array.concat(values)`, obviously.\n *\n * Intuitively, this is correct because when adding a lot of elements, the\n * chosen strategies does not need to handle the `arguments` object to\n * execute #.apply's variadicity and because the array know its final length\n * at the beginning, avoiding potential multiple reallocations of the underlying\n * contiguous array. Some engines may be able to optimize the loop of push\n * operations but empirically they don't seem to do so.\n */\n\n/**\n * Extends the target array with the given values.\n *\n * @param  {array} array  - Target array.\n * @param  {array} values - Values to add.\n */\nmodule.exports = function extend(array, values) {\n  var l2 = values.length;\n\n  if (l2 === 0)\n    return;\n\n  var l1 = array.length;\n\n  array.length += l2;\n\n  for (var i = 0; i < l2; i++)\n    array[l1 + i] = values[i];\n};\n\n\n//# sourceURL=webpack:///./node_modules/@yomguithereal/helpers/extend.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/graphology-metrics/extent.js":
/*!***************************************************!*\
  !*** ./node_modules/graphology-metrics/extent.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Graphology Extent\n * ==================\n *\n * Simple function returning the extent of selected attributes of the graph.\n */\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"./node_modules/graphology-utils/is-graph.js\");\n\n/**\n * Function returning the extent of the selected node attributes.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string|array} attribute - Single or multiple attributes.\n * @return {array|object}\n */\nfunction nodeExtent(graph, attribute) {\n  if (!isGraph(graph))\n    throw new Error('graphology-metrics/extent: the given graph is not a valid graphology instance.');\n\n  var attributes = [].concat(attribute);\n\n  var nodes = graph.nodes(),\n      node,\n      data,\n      value,\n      key,\n      a,\n      i,\n      l;\n\n  var results = {};\n\n  for (a = 0; a < attributes.length; a++) {\n    key = attributes[a];\n\n    results[key] = [Infinity, -Infinity];\n  }\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    node = nodes[i];\n    data = graph.getNodeAttributes(node);\n\n    for (a = 0; a < attributes.length; a++) {\n      key = attributes[a];\n      value = data[key];\n\n      if (value < results[key][0])\n        results[key][0] = value;\n\n      if (value > results[key][1])\n        results[key][1] = value;\n    }\n  }\n\n  return typeof attribute === 'string' ? results[attribute] : results;\n}\n\n/**\n * Function returning the extent of the selected edge attributes.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string|array} attribute - Single or multiple attributes.\n * @return {array|object}\n */\nfunction edgeExtent(graph, attribute) {\n  if (!isGraph(graph))\n    throw new Error('graphology-metrics/extent: the given graph is not a valid graphology instance.');\n\n  var attributes = [].concat(attribute);\n\n  var edges = graph.edges(),\n      edge,\n      data,\n      value,\n      key,\n      a,\n      i,\n      l;\n\n  var results = {};\n\n  for (a = 0; a < attributes.length; a++) {\n    key = attributes[a];\n\n    results[key] = [Infinity, -Infinity];\n  }\n\n  for (i = 0, l = edges.length; i < l; i++) {\n    edge = edges[i];\n    data = graph.getEdgeAttributes(edge);\n\n    for (a = 0; a < attributes.length; a++) {\n      key = attributes[a];\n      value = data[key];\n\n      if (value < results[key][0])\n        results[key][0] = value;\n\n      if (value > results[key][1])\n        results[key][1] = value;\n    }\n  }\n\n  return typeof attribute === 'string' ? results[attribute] : results;\n}\n\n/**\n * Exporting.\n */\nvar extent = nodeExtent;\nextent.nodeExtent = nodeExtent;\nextent.edgeExtent = edgeExtent;\n\nmodule.exports = extent;\n\n\n//# sourceURL=webpack:///./node_modules/graphology-metrics/extent.js?");

/***/ }),

/***/ "./node_modules/graphology-utils/is-graph.js":
/*!***************************************************!*\
  !*** ./node_modules/graphology-utils/is-graph.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n\n\n//# sourceURL=webpack:///./node_modules/graphology-utils/is-graph.js?");

/***/ }),

/***/ "./node_modules/graphology/dist/graphology.umd.min.js":
/*!************************************************************!*\
  !*** ./node_modules/graphology/dist/graphology.umd.min.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(e,t){ true?module.exports=t():undefined}(this,(function(){\"use strict\";function e(t){return(e=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(t)}function t(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}function n(e){return(n=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function r(e,t){return(r=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function i(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function o(e,t,n){return(o=i()?Reflect.construct:function(e,t,n){var i=[null];i.push.apply(i,t);var o=new(Function.bind.apply(e,i));return n&&r(o,n.prototype),o}).apply(null,arguments)}function a(e){var t=\"function\"==typeof Map?new Map:void 0;return(a=function(e){if(null===e||(i=e,-1===Function.toString.call(i).indexOf(\"[native code]\")))return e;var i;if(\"function\"!=typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,a)}function a(){return o(e,arguments,n(this).constructor)}return a.prototype=Object.create(e.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}}),r(a,e)})(e)}function c(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}function d(){for(var e=arguments[0]||{},t=1,n=arguments.length;t<n;t++)if(arguments[t])for(var r in arguments[t])e[r]=arguments[t][r];return e}function u(e,t,n,r){var i=e._nodes.get(t),o=null;return i?o=\"mixed\"===r?i.out&&i.out[n]||i.undirected&&i.undirected[n]:\"directed\"===r?i.out&&i.out[n]:i.undirected&&i.undirected[n]:o}function s(t){return null!==t&&\"object\"===e(t)&&\"function\"==typeof t.addUndirectedEdgeWithKey&&\"function\"==typeof t.dropNode}function h(t){return\"object\"===e(t)&&null!==t&&t.constructor===Object}function f(e){for(var t=\"\"+e,n=\"\",r=0,i=t.length;r<i;r++){n=t[i-r-1]+n,(r-2)%3||r===i-1||(n=\",\"+n)}return n}function p(e,t,n){Object.defineProperty(e,t,{enumerable:!1,configurable:!1,writable:!0,value:n})}function g(e,t,n){var r={enumerable:!0,configurable:!0};\"function\"==typeof n?r.get=n:(r.value=n,r.writable=!1),Object.defineProperty(e,t,r)}function l(){}function y(){y.init.call(this)}function v(e){return void 0===e._maxListeners?y.defaultMaxListeners:e._maxListeners}function w(e,t,n){if(t)e.call(n);else for(var r=e.length,i=S(e,r),o=0;o<r;++o)i[o].call(n)}function b(e,t,n,r){if(t)e.call(n,r);else for(var i=e.length,o=S(e,i),a=0;a<i;++a)o[a].call(n,r)}function m(e,t,n,r,i){if(t)e.call(n,r,i);else for(var o=e.length,a=S(e,o),c=0;c<o;++c)a[c].call(n,r,i)}function _(e,t,n,r,i,o){if(t)e.call(n,r,i,o);else for(var a=e.length,c=S(e,a),d=0;d<a;++d)c[d].call(n,r,i,o)}function G(e,t,n,r){if(t)e.apply(n,r);else for(var i=e.length,o=S(e,i),a=0;a<i;++a)o[a].apply(n,r)}function E(e,t,n,r){var i,o,a,c;if(\"function\"!=typeof n)throw new TypeError('\"listener\" argument must be a function');if((o=e._events)?(o.newListener&&(e.emit(\"newListener\",t,n.listener?n.listener:n),o=e._events),a=o[t]):(o=e._events=new l,e._eventsCount=0),a){if(\"function\"==typeof a?a=o[t]=r?[n,a]:[a,n]:r?a.unshift(n):a.push(n),!a.warned&&(i=v(e))&&i>0&&a.length>i){a.warned=!0;var d=new Error(\"Possible EventEmitter memory leak detected. \"+a.length+\" \"+t+\" listeners added. Use emitter.setMaxListeners() to increase limit\");d.name=\"MaxListenersExceededWarning\",d.emitter=e,d.type=t,d.count=a.length,c=d,\"function\"==typeof console.warn?console.warn(c):console.log(c)}}else a=o[t]=n,++e._eventsCount;return e}function k(e,t,n){var r=!1;function i(){e.removeListener(t,i),r||(r=!0,n.apply(e,arguments))}return i.listener=n,i}function x(e){var t=this._events;if(t){var n=t[e];if(\"function\"==typeof n)return 1;if(n)return n.length}return 0}function S(e,t){for(var n=new Array(t);t--;)n[t]=e[t];return n}function A(e){Object.defineProperty(this,\"_next\",{writable:!1,enumerable:!1,value:e}),this.done=!1}l.prototype=Object.create(null),y.EventEmitter=y,y.usingDomains=!1,y.prototype.domain=void 0,y.prototype._events=void 0,y.prototype._maxListeners=void 0,y.defaultMaxListeners=10,y.init=function(){this.domain=null,y.usingDomains&&(void 0).active,this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=new l,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},y.prototype.setMaxListeners=function(e){if(\"number\"!=typeof e||e<0||isNaN(e))throw new TypeError('\"n\" argument must be a positive number');return this._maxListeners=e,this},y.prototype.getMaxListeners=function(){return v(this)},y.prototype.emit=function(e){var t,n,r,i,o,a,c,d=\"error\"===e;if(a=this._events)d=d&&null==a.error;else if(!d)return!1;if(c=this.domain,d){if(t=arguments[1],!c){if(t instanceof Error)throw t;var u=new Error('Uncaught, unspecified \"error\" event. ('+t+\")\");throw u.context=t,u}return t||(t=new Error('Uncaught, unspecified \"error\" event')),t.domainEmitter=this,t.domain=c,t.domainThrown=!1,c.emit(\"error\",t),!1}if(!(n=a[e]))return!1;var s=\"function\"==typeof n;switch(r=arguments.length){case 1:w(n,s,this);break;case 2:b(n,s,this,arguments[1]);break;case 3:m(n,s,this,arguments[1],arguments[2]);break;case 4:_(n,s,this,arguments[1],arguments[2],arguments[3]);break;default:for(i=new Array(r-1),o=1;o<r;o++)i[o-1]=arguments[o];G(n,s,this,i)}return!0},y.prototype.addListener=function(e,t){return E(this,e,t,!1)},y.prototype.on=y.prototype.addListener,y.prototype.prependListener=function(e,t){return E(this,e,t,!0)},y.prototype.once=function(e,t){if(\"function\"!=typeof t)throw new TypeError('\"listener\" argument must be a function');return this.on(e,k(this,e,t)),this},y.prototype.prependOnceListener=function(e,t){if(\"function\"!=typeof t)throw new TypeError('\"listener\" argument must be a function');return this.prependListener(e,k(this,e,t)),this},y.prototype.removeListener=function(e,t){var n,r,i,o,a;if(\"function\"!=typeof t)throw new TypeError('\"listener\" argument must be a function');if(!(r=this._events))return this;if(!(n=r[e]))return this;if(n===t||n.listener&&n.listener===t)0==--this._eventsCount?this._events=new l:(delete r[e],r.removeListener&&this.emit(\"removeListener\",e,n.listener||t));else if(\"function\"!=typeof n){for(i=-1,o=n.length;o-- >0;)if(n[o]===t||n[o].listener&&n[o].listener===t){a=n[o].listener,i=o;break}if(i<0)return this;if(1===n.length){if(n[0]=void 0,0==--this._eventsCount)return this._events=new l,this;delete r[e]}else!function(e,t){for(var n=t,r=n+1,i=e.length;r<i;n+=1,r+=1)e[n]=e[r];e.pop()}(n,i);r.removeListener&&this.emit(\"removeListener\",e,a||t)}return this},y.prototype.removeAllListeners=function(e){var t,n;if(!(n=this._events))return this;if(!n.removeListener)return 0===arguments.length?(this._events=new l,this._eventsCount=0):n[e]&&(0==--this._eventsCount?this._events=new l:delete n[e]),this;if(0===arguments.length){for(var r,i=Object.keys(n),o=0;o<i.length;++o)\"removeListener\"!==(r=i[o])&&this.removeAllListeners(r);return this.removeAllListeners(\"removeListener\"),this._events=new l,this._eventsCount=0,this}if(\"function\"==typeof(t=n[e]))this.removeListener(e,t);else if(t)do{this.removeListener(e,t[t.length-1])}while(t[0]);return this},y.prototype.listeners=function(e){var t,n=this._events;return n&&(t=n[e])?\"function\"==typeof t?[t.listener||t]:function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(t):[]},y.listenerCount=function(e,t){return\"function\"==typeof e.listenerCount?e.listenerCount(t):x.call(e,t)},y.prototype.listenerCount=x,y.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]},A.prototype.next=function(){if(this.done)return{done:!0};var e=this._next();return e.done&&(this.done=!0),e},\"undefined\"!=typeof Symbol&&(A.prototype[Symbol.iterator]=function(){return this}),A.of=function(){var e=arguments,t=e.length,n=0;return new A((function(){return n>=t?{done:!0}:{done:!1,value:e[n++]}}))},A.empty=function(){var e=new A(null);return e.done=!0,e},A.is=function(e){return e instanceof A||\"object\"==typeof e&&null!==e&&\"function\"==typeof e.next};var N=A,D=function(e,t){for(var n,r=arguments.length>1?t:1/0,i=r!==1/0?new Array(r):[],o=0;;){if(o===r)return i;if((n=e.next()).done)return o!==t?i.slice(0,o):i;i[o++]=n.value}},L=function(e){function n(t,n){var r;return(r=e.call(this)||this).name=\"GraphError\",r.message=t||\"\",r.data=n||{},r}return t(n,e),n}(a(Error)),j=function(e){function n(t,r){var i;return(i=e.call(this,t,r)||this).name=\"InvalidArgumentsGraphError\",\"function\"==typeof Error.captureStackTrace&&Error.captureStackTrace(c(i),n.prototype.constructor),i}return t(n,e),n}(L),U=function(e){function n(t,r){var i;return(i=e.call(this,t,r)||this).name=\"NotFoundGraphError\",\"function\"==typeof Error.captureStackTrace&&Error.captureStackTrace(c(i),n.prototype.constructor),i}return t(n,e),n}(L),z=function(e){function n(t,r){var i;return(i=e.call(this,t,r)||this).name=\"UsageGraphError\",\"function\"==typeof Error.captureStackTrace&&Error.captureStackTrace(c(i),n.prototype.constructor),i}return t(n,e),n}(L);function O(e,t){this.key=e,this.attributes=t,this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.directedSelfLoops=0,this.undirectedSelfLoops=0,this.in={},this.out={},this.undirected={}}function K(e,t){this.key=e,this.attributes=t||{},this.inDegree=0,this.outDegree=0,this.directedSelfLoops=0,this.in={},this.out={}}function M(e,t){this.key=e,this.attributes=t||{},this.undirectedDegree=0,this.undirectedSelfLoops=0,this.undirected={}}function C(e,t,n,r,i){this.key=e,this.attributes=i,this.source=n,this.target=r,this.generatedKey=t}function T(e,t,n,r,i){this.key=e,this.attributes=i,this.source=n,this.target=r,this.generatedKey=t}function P(e,t,n,r,i,o,a){var c=e.multi,d=t?\"undirected\":\"out\",u=t?\"undirected\":\"in\",s=o[d][i];void 0===s&&(s=c?new Set:n,o[d][i]=s),c&&s.add(n),r!==i&&void 0===a[u][r]&&(a[u][r]=s)}function W(e,t,n){var r=e.multi,i=n.source,o=n.target,a=i.key,c=o.key,d=i[t?\"undirected\":\"out\"],u=t?\"undirected\":\"in\";if(c in d)if(r){var s=d[c];1===s.size?(delete d[c],delete o[u][a]):s.delete(n)}else delete d[c];r||delete o[u][a]}K.prototype.upgradeToMixed=function(){this.undirectedDegree=0,this.undirectedSelfLoops=0,this.undirected={}},M.prototype.upgradeToMixed=function(){this.inDegree=0,this.outDegree=0,this.directedSelfLoops=0,this.in={},this.out={}};var R=[{name:function(e){return\"get\".concat(e,\"Attribute\")},attacher:function(e,t,n,r){e.prototype[t]=function(e,i){var o;if(\"mixed\"!==this.type&&\"mixed\"!==n&&n!==this.type)throw new z(\"Graph.\".concat(t,\": cannot find this type of edges in your \").concat(this.type,\" graph.\"));if(arguments.length>2){if(this.multi)throw new z(\"Graph.\".concat(t,\": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));var a=\"\"+e,c=\"\"+i;if(i=arguments[2],!(o=u(this,a,c,n)))throw new U(\"Graph.\".concat(t,': could not find an edge for the given path (\"').concat(a,'\" - \"').concat(c,'\").'))}else if(e=\"\"+e,!(o=this._edges.get(e)))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" edge in the graph.'));if(\"mixed\"!==n&&!(o instanceof r))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" ').concat(n,\" edge in the graph.\"));return o.attributes[i]}}},{name:function(e){return\"get\".concat(e,\"Attributes\")},attacher:function(e,t,n,r){e.prototype[t]=function(e){var i;if(\"mixed\"!==this.type&&\"mixed\"!==n&&n!==this.type)throw new z(\"Graph.\".concat(t,\": cannot find this type of edges in your \").concat(this.type,\" graph.\"));if(arguments.length>1){if(this.multi)throw new z(\"Graph.\".concat(t,\": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));var o=\"\"+e,a=\"\"+arguments[1];if(!(i=u(this,o,a,n)))throw new U(\"Graph.\".concat(t,': could not find an edge for the given path (\"').concat(o,'\" - \"').concat(a,'\").'))}else if(e=\"\"+e,!(i=this._edges.get(e)))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" edge in the graph.'));if(\"mixed\"!==n&&!(i instanceof r))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" ').concat(n,\" edge in the graph.\"));return i.attributes}}},{name:function(e){return\"has\".concat(e,\"Attribute\")},attacher:function(e,t,n,r){e.prototype[t]=function(e,i){var o;if(\"mixed\"!==this.type&&\"mixed\"!==n&&n!==this.type)throw new z(\"Graph.\".concat(t,\": cannot find this type of edges in your \").concat(this.type,\" graph.\"));if(arguments.length>2){if(this.multi)throw new z(\"Graph.\".concat(t,\": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));var a=\"\"+e,c=\"\"+i;if(i=arguments[2],!(o=u(this,a,c,n)))throw new U(\"Graph.\".concat(t,': could not find an edge for the given path (\"').concat(a,'\" - \"').concat(c,'\").'))}else if(e=\"\"+e,!(o=this._edges.get(e)))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" edge in the graph.'));if(\"mixed\"!==n&&!(o instanceof r))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" ').concat(n,\" edge in the graph.\"));return o.attributes.hasOwnProperty(i)}}},{name:function(e){return\"set\".concat(e,\"Attribute\")},attacher:function(e,t,n,r){e.prototype[t]=function(e,i,o){var a;if(\"mixed\"!==this.type&&\"mixed\"!==n&&n!==this.type)throw new z(\"Graph.\".concat(t,\": cannot find this type of edges in your \").concat(this.type,\" graph.\"));if(arguments.length>3){if(this.multi)throw new z(\"Graph.\".concat(t,\": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));var c=\"\"+e,d=\"\"+i;if(i=arguments[2],o=arguments[3],!(a=u(this,c,d,n)))throw new U(\"Graph.\".concat(t,': could not find an edge for the given path (\"').concat(c,'\" - \"').concat(d,'\").'))}else if(e=\"\"+e,!(a=this._edges.get(e)))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" edge in the graph.'));if(\"mixed\"!==n&&!(a instanceof r))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" ').concat(n,\" edge in the graph.\"));return a.attributes[i]=o,this.emit(\"edgeAttributesUpdated\",{key:a.key,type:\"set\",meta:{name:i,value:o}}),this}}},{name:function(e){return\"update\".concat(e,\"Attribute\")},attacher:function(e,t,n,r){e.prototype[t]=function(e,i,o){var a;if(\"mixed\"!==this.type&&\"mixed\"!==n&&n!==this.type)throw new z(\"Graph.\".concat(t,\": cannot find this type of edges in your \").concat(this.type,\" graph.\"));if(arguments.length>3){if(this.multi)throw new z(\"Graph.\".concat(t,\": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));var c=\"\"+e,d=\"\"+i;if(i=arguments[2],o=arguments[3],!(a=u(this,c,d,n)))throw new U(\"Graph.\".concat(t,': could not find an edge for the given path (\"').concat(c,'\" - \"').concat(d,'\").'))}else if(e=\"\"+e,!(a=this._edges.get(e)))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" edge in the graph.'));if(\"function\"!=typeof o)throw new j(\"Graph.\".concat(t,\": updater should be a function.\"));if(\"mixed\"!==n&&!(a instanceof r))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" ').concat(n,\" edge in the graph.\"));return a.attributes[i]=o(a.attributes[i]),this.emit(\"edgeAttributesUpdated\",{key:a.key,type:\"set\",meta:{name:i,value:a.attributes[i]}}),this}}},{name:function(e){return\"remove\".concat(e,\"Attribute\")},attacher:function(e,t,n,r){e.prototype[t]=function(e,i){var o;if(\"mixed\"!==this.type&&\"mixed\"!==n&&n!==this.type)throw new z(\"Graph.\".concat(t,\": cannot find this type of edges in your \").concat(this.type,\" graph.\"));if(arguments.length>2){if(this.multi)throw new z(\"Graph.\".concat(t,\": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));var a=\"\"+e,c=\"\"+i;if(i=arguments[2],!(o=u(this,a,c,n)))throw new U(\"Graph.\".concat(t,': could not find an edge for the given path (\"').concat(a,'\" - \"').concat(c,'\").'))}else if(e=\"\"+e,!(o=this._edges.get(e)))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" edge in the graph.'));if(\"mixed\"!==n&&!(o instanceof r))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" ').concat(n,\" edge in the graph.\"));return delete o.attributes[i],this.emit(\"edgeAttributesUpdated\",{key:o.key,type:\"remove\",meta:{name:i}}),this}}},{name:function(e){return\"replace\".concat(e,\"Attributes\")},attacher:function(e,t,n,r){e.prototype[t]=function(e,i){var o;if(\"mixed\"!==this.type&&\"mixed\"!==n&&n!==this.type)throw new z(\"Graph.\".concat(t,\": cannot find this type of edges in your \").concat(this.type,\" graph.\"));if(arguments.length>2){if(this.multi)throw new z(\"Graph.\".concat(t,\": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));var a=\"\"+e,c=\"\"+i;if(i=arguments[2],!(o=u(this,a,c,n)))throw new U(\"Graph.\".concat(t,': could not find an edge for the given path (\"').concat(a,'\" - \"').concat(c,'\").'))}else if(e=\"\"+e,!(o=this._edges.get(e)))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" edge in the graph.'));if(!h(i))throw new j(\"Graph.\".concat(t,\": provided attributes are not a plain object.\"));if(\"mixed\"!==n&&!(o instanceof r))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" ').concat(n,\" edge in the graph.\"));var d=o.attributes;return o.attributes=i,this.emit(\"edgeAttributesUpdated\",{key:o.key,type:\"replace\",meta:{before:d,after:i}}),this}}},{name:function(e){return\"merge\".concat(e,\"Attributes\")},attacher:function(e,t,n,r){e.prototype[t]=function(e,i){var o;if(\"mixed\"!==this.type&&\"mixed\"!==n&&n!==this.type)throw new z(\"Graph.\".concat(t,\": cannot find this type of edges in your \").concat(this.type,\" graph.\"));if(arguments.length>2){if(this.multi)throw new z(\"Graph.\".concat(t,\": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));var a=\"\"+e,c=\"\"+i;if(i=arguments[2],!(o=u(this,a,c,n)))throw new U(\"Graph.\".concat(t,': could not find an edge for the given path (\"').concat(a,'\" - \"').concat(c,'\").'))}else if(e=\"\"+e,!(o=this._edges.get(e)))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" edge in the graph.'));if(!h(i))throw new j(\"Graph.\".concat(t,\": provided attributes are not a plain object.\"));if(\"mixed\"!==n&&!(o instanceof r))throw new U(\"Graph.\".concat(t,': could not find the \"').concat(e,'\" ').concat(n,\" edge in the graph.\"));return d(o.attributes,i),this.emit(\"edgeAttributesUpdated\",{key:o.key,type:\"merge\",meta:{data:i}}),this}}}];var I=function(){var e,t=arguments,n=-1;return new N((function r(){if(!e){if(++n>=t.length)return{done:!0};e=t[n]}var i=e.next();return i.done?(e=null,r()):i}))},F=[{name:\"edges\",type:\"mixed\"},{name:\"inEdges\",type:\"directed\",direction:\"in\"},{name:\"outEdges\",type:\"directed\",direction:\"out\"},{name:\"inboundEdges\",type:\"mixed\",direction:\"in\"},{name:\"outboundEdges\",type:\"mixed\",direction:\"out\"},{name:\"directedEdges\",type:\"directed\"},{name:\"undirectedEdges\",type:\"undirected\"}];function Y(e,t){for(var n in t)t[n]instanceof Set?t[n].forEach((function(t){return e.push(t.key)})):e.push(t[n].key)}function J(e,t){for(var n in e){var r=e[n];t(r.key,r.attributes,r.source.key,r.target.key,r.source.attributes,r.target.attributes)}}function q(e,t){for(var n in e)e[n].forEach((function(e){return t(e.key,e.attributes,e.source.key,e.target.key,e.source.attributes,e.target.attributes)}))}function B(e){var t=Object.keys(e),n=t.length,r=null,i=0;return new N((function o(){var a;if(r){var c=r.next();if(c.done)return r=null,i++,o();a=c.value}else{if(i>=n)return{done:!0};var d=t[i];if((a=e[d])instanceof Set)return r=a.values(),o();i++}return{done:!1,value:[a.key,a.attributes,a.source.key,a.target.key,a.source.attributes,a.target.attributes]}}))}function H(e,t,n){n in t&&(t[n]instanceof Set?t[n].forEach((function(t){return e.push(t.key)})):e.push(t[n].key))}function Q(e,t,n){if(t in e)if(e[t]instanceof Set)e[t].forEach((function(e){return n(e.key,e.attributes,e.source.key,e.target.key,e.source.attributes,e.target.attributes)}));else{var r=e[t];n(r.key,r.attributes,r.source.key,r.target.key,r.source.attributes,r.target.attributes)}}function V(e,t){var n=e[t];if(n instanceof Set){var r=n.values();return new N((function(){var e=r.next();if(e.done)return e;var t=e.value;return{done:!1,value:[t.key,t.attributes,t.source.key,t.target.key,t.source.attributes,t.target.attributes]}}))}return N.of([n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes])}function X(e,t){if(0===e.size)return[];if(\"mixed\"===t||t===e.type)return D(e._edges.keys(),e._edges.size);var n=\"undirected\"===t?e.undirectedSize:e.directedSize,r=new Array(n),i=\"undirected\"===t,o=0;return e._edges.forEach((function(e,t){e instanceof T===i&&(r[o++]=t)})),r}function Z(e,t,n){if(0!==e.size)if(\"mixed\"===t||t===e.type)e._edges.forEach((function(e,t){var r=e.attributes,i=e.source,o=e.target;n(t,r,i.key,o.key,i.attributes,o.attributes)}));else{var r=\"undirected\"===t;e._edges.forEach((function(e,t){if(e instanceof T===r){var i=e.attributes,o=e.source,a=e.target;n(t,i,o.key,a.key,o.attributes,a.attributes)}}))}}function $(e,t){return 0===e.size?N.empty():\"mixed\"===t?(n=e._edges.values(),new N((function(){var e=n.next();if(e.done)return e;var t=e.value;return{value:[t.key,t.attributes,t.source.key,t.target.key,t.source.attributes,t.target.attributes],done:!1}}))):(n=e._edges.values(),new N((function e(){var r=n.next();if(r.done)return r;var i=r.value;return i instanceof T==(\"undirected\"===t)?{value:[i.key,i.attributes,i.source.key,i.target.key,i.source.attributes,i.target.attributes],done:!1}:e()})));var n}function ee(e,t,n){var r=[];return\"undirected\"!==e&&(\"out\"!==t&&Y(r,n.in),\"in\"!==t&&Y(r,n.out)),\"directed\"!==e&&Y(r,n.undirected),r}function te(e,t,n,r,i){var o=e?q:J;\"undirected\"!==t&&(\"out\"!==n&&o(r.in,i),\"in\"!==n&&o(r.out,i)),\"directed\"!==t&&o(r.undirected,i)}function ne(e,t,n){var r=N.empty();return\"undirected\"!==e&&(\"out\"!==t&&void 0!==n.in&&(r=I(r,B(n.in))),\"in\"!==t&&void 0!==n.out&&(r=I(r,B(n.out)))),\"directed\"!==e&&void 0!==n.undirected&&(r=I(r,B(n.undirected))),r}function re(e,t,n,r){var i=[];return\"undirected\"!==e&&(void 0!==n.in&&\"out\"!==t&&H(i,n.in,r),void 0!==n.out&&\"in\"!==t&&H(i,n.out,r)),\"directed\"!==e&&void 0!==n.undirected&&H(i,n.undirected,r),i}function ie(e,t,n,r,i){\"undirected\"!==e&&(void 0!==n.in&&\"out\"!==t&&Q(n.in,r,i),void 0!==n.out&&\"in\"!==t&&Q(n.out,r,i)),\"directed\"!==e&&void 0!==n.undirected&&Q(n.undirected,r,i)}function oe(e,t,n,r){var i=N.empty();return\"undirected\"!==e&&(void 0!==n.in&&\"out\"!==t&&r in n.in&&(i=I(i,V(n.in,r))),void 0!==n.out&&\"in\"!==t&&r in n.out&&(i=I(i,V(n.out,r)))),\"directed\"!==e&&void 0!==n.undirected&&r in n.undirected&&(i=I(i,V(n.undirected,r))),i}var ae=[{name:\"neighbors\",type:\"mixed\"},{name:\"inNeighbors\",type:\"directed\",direction:\"in\"},{name:\"outNeighbors\",type:\"directed\",direction:\"out\"},{name:\"inboundNeighbors\",type:\"mixed\",direction:\"in\"},{name:\"outboundNeighbors\",type:\"mixed\",direction:\"out\"},{name:\"directedNeighbors\",type:\"directed\"},{name:\"undirectedNeighbors\",type:\"undirected\"}];function ce(e,t){if(void 0!==t)for(var n in t)e.add(n)}function de(e,t,n){if(\"mixed\"!==e){if(\"undirected\"===e)return Object.keys(n.undirected);if(\"string\"==typeof t)return Object.keys(n[t])}var r=new Set;return\"undirected\"!==e&&(\"out\"!==t&&ce(r,n.in),\"in\"!==t&&ce(r,n.out)),\"directed\"!==e&&ce(r,n.undirected),D(r.values(),r.size)}function ue(e,t,n){for(var r in t){var i=t[r];i instanceof Set&&(i=i.values().next().value);var o=i.source,a=i.target,c=o===e?a:o;n(c.key,c.attributes)}}function se(e,t,n,r){for(var i in n){var o=n[i];o instanceof Set&&(o=o.values().next().value);var a=o.source,c=o.target,d=a===t?c:a;e.has(d.key)||(e.add(d.key),r(d.key,d.attributes))}}function he(e,t){var n=Object.keys(t),r=n.length,i=0;return new N((function(){if(i>=r)return{done:!0};var o=t[n[i++]];o instanceof Set&&(o=o.values().next().value);var a=o.source,c=o.target,d=a===e?c:a;return{done:!1,value:[d.key,d.attributes]}}))}function fe(e,t,n){var r=Object.keys(n),i=r.length,o=0;return new N((function a(){if(o>=i)return{done:!0};var c=n[r[o++]];c instanceof Set&&(c=c.values().next().value);var d=c.source,u=c.target,s=d===t?u:d;return e.has(s.key)?a():(e.add(s.key),{done:!1,value:[s.key,s.attributes]})}))}function pe(e,t,n,r,i){var o=e._nodes.get(r);if(\"undirected\"!==t){if(\"out\"!==n&&void 0!==o.in)for(var a in o.in)if(a===i)return!0;if(\"in\"!==n&&void 0!==o.out)for(var c in o.out)if(c===i)return!0}if(\"directed\"!==t&&void 0!==o.undirected)for(var d in o.undirected)if(d===i)return!0;return!1}function ge(e,t){var n=t.name,r=t.type,i=t.direction,o=\"forEach\"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t){if(\"mixed\"===r||\"mixed\"===this.type||r===this.type){e=\"\"+e;var n=this._nodes.get(e);if(void 0===n)throw new U(\"Graph.\".concat(o,': could not find the \"').concat(e,'\" node in the graph.'));!function(e,t,n,r){if(\"mixed\"!==e){if(\"undirected\"===e)return ue(n,n.undirected,r);if(\"string\"==typeof t)return ue(n,n[t],r)}var i=new Set;\"undirected\"!==e&&(\"out\"!==t&&se(i,n,n.in,r),\"in\"!==t&&se(i,n,n.out,r)),\"directed\"!==e&&se(i,n,n.undirected,r)}(\"mixed\"===r?this.type:r,i,n,t)}}}function le(e,t){var n=t.name,r=t.type,i=t.direction,o=n.slice(0,-1)+\"Entries\";e.prototype[o]=function(e){if(\"mixed\"!==r&&\"mixed\"!==this.type&&r!==this.type)return N.empty();e=\"\"+e;var t=this._nodes.get(e);if(void 0===t)throw new U(\"Graph.\".concat(o,': could not find the \"').concat(e,'\" node in the graph.'));return function(e,t,n){if(\"mixed\"!==e){if(\"undirected\"===e)return he(n,n.undirected);if(\"string\"==typeof t)return he(n,n[t])}var r=N.empty(),i=new Set;return\"undirected\"!==e&&(\"out\"!==t&&(r=I(r,fe(i,n,n.in))),\"in\"!==t&&(r=I(r,fe(i,n,n.out)))),\"directed\"!==e&&(r=I(r,fe(i,n,n.undirected))),r}(\"mixed\"===r?this.type:r,i,t)}}function ye(e,t){var n={key:e};return Object.keys(t.attributes).length&&(n.attributes=d({},t.attributes)),n}function ve(e,t){var n={source:t.source.key,target:t.target.key};return t.generatedKey||(n.key=e),Object.keys(t.attributes).length&&(n.attributes=d({},t.attributes)),t instanceof T&&(n.undirected=!0),n}function we(e){return h(e)?\"key\"in e?!(\"attributes\"in e)||h(e.attributes)&&null!==e.attributes?null:\"invalid-attributes\":\"no-key\":\"not-object\"}function be(e){return h(e)?\"source\"in e?\"target\"in e?!(\"attributes\"in e)||h(e.attributes)&&null!==e.attributes?\"undirected\"in e&&\"boolean\"!=typeof e.undirected?\"invalid-undirected\":null:\"invalid-attributes\":\"no-target\":\"no-source\":\"not-object\"}var me=new Set([\"directed\",\"undirected\",\"mixed\"]),_e=new Set([\"domain\",\"_events\",\"_eventsCount\",\"_maxListeners\"]),Ge={allowSelfLoops:!0,edgeKeyGenerator:null,multi:!1,type:\"mixed\"};function Ee(e,t,n,r,i,o,a,c){if(!r&&\"undirected\"===e.type)throw new z(\"Graph.\".concat(t,\": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.\"));if(r&&\"directed\"===e.type)throw new z(\"Graph.\".concat(t,\": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.\"));if(c&&!h(c))throw new j(\"Graph.\".concat(t,': invalid attributes. Expecting an object but got \"').concat(c,'\"'));if(o=\"\"+o,a=\"\"+a,c=c||{},!e.allowSelfLoops&&o===a)throw new z(\"Graph.\".concat(t,': source & target are the same (\"').concat(o,\"\\\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.\"));var d=e._nodes.get(o),u=e._nodes.get(a);if(!d)throw new U(\"Graph.\".concat(t,': source node \"').concat(o,'\" not found.'));if(!u)throw new U(\"Graph.\".concat(t,': target node \"').concat(a,'\" not found.'));var s={key:null,undirected:r,source:o,target:a,attributes:c};if(n&&(i=e._edgeKeyGenerator(s)),i=\"\"+i,e._edges.has(i))throw new z(\"Graph.\".concat(t,': the \"').concat(i,'\" edge already exists in the graph.'));if(!e.multi&&(r?void 0!==d.undirected[a]:void 0!==d.out[a]))throw new z(\"Graph.\".concat(t,': an edge linking \"').concat(o,'\" to \"').concat(a,\"\\\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.\"));var f=new(r?T:C)(i,n,d,u,c);return e._edges.set(i,f),o===a?r?d.undirectedSelfLoops++:d.directedSelfLoops++:r?(d.undirectedDegree++,u.undirectedDegree++):(d.outDegree++,u.inDegree++),P(e,r,f,o,a,d,u),r?e._undirectedSize++:e._directedSize++,s.key=i,e.emit(\"edgeAdded\",s),i}function ke(e,t,n,r,i,o,a,c){if(!r&&\"undirected\"===e.type)throw new z(\"Graph.\".concat(t,\": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.\"));if(r&&\"directed\"===e.type)throw new z(\"Graph.\".concat(t,\": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.\"));if(c&&!h(c))throw new j(\"Graph.\".concat(t,': invalid attributes. Expecting an object but got \"').concat(c,'\"'));if(o=\"\"+o,a=\"\"+a,c=c||{},!e.allowSelfLoops&&o===a)throw new z(\"Graph.\".concat(t,': source & target are the same (\"').concat(o,\"\\\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.\"));var s,f,p=e._nodes.get(o),g=e._nodes.get(a),l=null;if(!n&&(s=e._edges.get(i))){if(s.source!==o||s.target!==a||r&&(s.source!==a||s.target!==o))throw new z(\"Graph.\".concat(t,': inconsistency detected when attempting to merge the \"').concat(i,'\" edge with \"').concat(o,'\" source & \"').concat(a,'\" target vs. (').concat(s.source,\", \").concat(s.target,\").\"));l=i}if(l||e.multi||!p||(r?void 0===p.undirected[a]:void 0===p.out[a])||(f=u(e,o,a,r?\"undirected\":\"directed\")),f)return c?(d(f.attributes,c),l):l;var y={key:null,undirected:r,source:o,target:a,attributes:c};if(n&&(i=e._edgeKeyGenerator(y)),i=\"\"+i,e._edges.has(i))throw new z(\"Graph.\".concat(t,': the \"').concat(i,'\" edge already exists in the graph.'));return p||(e.addNode(o),p=e._nodes.get(o),o===a&&(g=p)),g||(e.addNode(a),g=e._nodes.get(a)),s=new(r?T:C)(i,n,p,g,c),e._edges.set(i,s),o===a?r?p.undirectedSelfLoops++:p.directedSelfLoops++:r?(p.undirectedDegree++,g.undirectedDegree++):(p.outDegree++,g.inDegree++),P(e,r,s,o,a,p,g),r?e._undirectedSize++:e._directedSize++,y.key=i,e.emit(\"edgeAdded\",y),i}var xe=function(e){function n(t){var n;if(n=e.call(this)||this,(t=d({},Ge,t)).edgeKeyGenerator&&\"function\"!=typeof t.edgeKeyGenerator)throw new j(\"Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \\\"\".concat(t.edgeKeyGenerator,'\".'));if(\"boolean\"!=typeof t.multi)throw new j(\"Graph.constructor: invalid 'multi' option. Expecting a boolean but got \\\"\".concat(t.multi,'\".'));if(!me.has(t.type))throw new j('Graph.constructor: invalid \\'type\\' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"'.concat(t.type,'\".'));if(\"boolean\"!=typeof t.allowSelfLoops)throw new j(\"Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \\\"\".concat(t.allowSelfLoops,'\".'));var r,i=\"mixed\"===t.type?O:\"directed\"===t.type?K:M;return p(c(n),\"NodeDataClass\",i),p(c(n),\"_attributes\",{}),p(c(n),\"_nodes\",new Map),p(c(n),\"_edges\",new Map),p(c(n),\"_directedSize\",0),p(c(n),\"_undirectedSize\",0),p(c(n),\"_edgeKeyGenerator\",t.edgeKeyGenerator||(r=0,function(){return\"_geid\".concat(r++,\"_\")})),p(c(n),\"_options\",t),_e.forEach((function(e){return p(c(n),e,n[e])})),g(c(n),\"order\",(function(){return n._nodes.size})),g(c(n),\"size\",(function(){return n._edges.size})),g(c(n),\"directedSize\",(function(){return n._directedSize})),g(c(n),\"undirectedSize\",(function(){return n._undirectedSize})),g(c(n),\"multi\",n._options.multi),g(c(n),\"type\",n._options.type),g(c(n),\"allowSelfLoops\",n._options.allowSelfLoops),n}t(n,e);var r=n.prototype;return r.hasNode=function(e){return this._nodes.has(\"\"+e)},r.hasDirectedEdge=function(e,t){if(\"undirected\"===this.type)return!1;if(1===arguments.length){var n=\"\"+e,r=this._edges.get(n);return!!r&&r instanceof C}if(2===arguments.length){e=\"\"+e,t=\"\"+t;var i=this._nodes.get(e);if(!i)return!1;var o=i.out[t];return!!o&&(!this.multi||!!o.size)}throw new j(\"Graph.hasDirectedEdge: invalid arity (\".concat(arguments.length,\", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.\"))},r.hasUndirectedEdge=function(e,t){if(\"directed\"===this.type)return!1;if(1===arguments.length){var n=\"\"+e,r=this._edges.get(n);return!!r&&r instanceof T}if(2===arguments.length){e=\"\"+e,t=\"\"+t;var i=this._nodes.get(e);if(!i)return!1;var o=i.undirected[t];return!!o&&(!this.multi||!!o.size)}throw new j(\"Graph.hasDirectedEdge: invalid arity (\".concat(arguments.length,\", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.\"))},r.hasEdge=function(e,t){if(1===arguments.length){var n=\"\"+e;return this._edges.has(n)}if(2===arguments.length){e=\"\"+e,t=\"\"+t;var r=this._nodes.get(e);if(!r)return!1;var i=void 0!==r.out&&r.out[t];return i||(i=void 0!==r.undirected&&r.undirected[t]),!!i&&(!this.multi||!!i.size)}throw new j(\"Graph.hasEdge: invalid arity (\".concat(arguments.length,\", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.\"))},r.directedEdge=function(e,t){if(\"undirected\"!==this.type){if(e=\"\"+e,t=\"\"+t,this.multi)throw new z(\"Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.\");var n=this._nodes.get(e);if(!n)throw new U('Graph.directedEdge: could not find the \"'.concat(e,'\" source node in the graph.'));if(!this._nodes.has(t))throw new U('Graph.directedEdge: could not find the \"'.concat(t,'\" target node in the graph.'));var r=n.out&&n.out[t]||void 0;return r?r.key:void 0}},r.undirectedEdge=function(e,t){if(\"directed\"!==this.type){if(e=\"\"+e,t=\"\"+t,this.multi)throw new z(\"Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.\");var n=this._nodes.get(e);if(!n)throw new U('Graph.undirectedEdge: could not find the \"'.concat(e,'\" source node in the graph.'));if(!this._nodes.has(t))throw new U('Graph.undirectedEdge: could not find the \"'.concat(t,'\" target node in the graph.'));var r=n.undirected&&n.undirected[t]||void 0;return r?r.key:void 0}},r.edge=function(e,t){if(this.multi)throw new z(\"Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.\");e=\"\"+e,t=\"\"+t;var n=this._nodes.get(e);if(!n)throw new U('Graph.edge: could not find the \"'.concat(e,'\" source node in the graph.'));if(!this._nodes.has(t))throw new U('Graph.edge: could not find the \"'.concat(t,'\" target node in the graph.'));var r=n.out&&n.out[t]||n.undirected&&n.undirected[t]||void 0;if(r)return r.key},r.inDegree=function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(\"boolean\"!=typeof t)throw new j('Graph.inDegree: Expecting a boolean but got \"'.concat(t,'\" for the second parameter (allowing self-loops to be counted).'));e=\"\"+e;var n=this._nodes.get(e);if(!n)throw new U('Graph.inDegree: could not find the \"'.concat(e,'\" node in the graph.'));if(\"undirected\"===this.type)return 0;var r=t?n.directedSelfLoops:0;return n.inDegree+r},r.outDegree=function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(\"boolean\"!=typeof t)throw new j('Graph.outDegree: Expecting a boolean but got \"'.concat(t,'\" for the second parameter (allowing self-loops to be counted).'));e=\"\"+e;var n=this._nodes.get(e);if(!n)throw new U('Graph.outDegree: could not find the \"'.concat(e,'\" node in the graph.'));if(\"undirected\"===this.type)return 0;var r=t?n.directedSelfLoops:0;return n.outDegree+r},r.directedDegree=function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(\"boolean\"!=typeof t)throw new j('Graph.directedDegree: Expecting a boolean but got \"'.concat(t,'\" for the second parameter (allowing self-loops to be counted).'));if(e=\"\"+e,!this.hasNode(e))throw new U('Graph.directedDegree: could not find the \"'.concat(e,'\" node in the graph.'));return\"undirected\"===this.type?0:this.inDegree(e,t)+this.outDegree(e,t)},r.undirectedDegree=function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(\"boolean\"!=typeof t)throw new j('Graph.undirectedDegree: Expecting a boolean but got \"'.concat(t,'\" for the second parameter (allowing self-loops to be counted).'));if(e=\"\"+e,!this.hasNode(e))throw new U('Graph.undirectedDegree: could not find the \"'.concat(e,'\" node in the graph.'));if(\"directed\"===this.type)return 0;var n=this._nodes.get(e),r=t?2*n.undirectedSelfLoops:0;return n.undirectedDegree+r},r.degree=function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(\"boolean\"!=typeof t)throw new j('Graph.degree: Expecting a boolean but got \"'.concat(t,'\" for the second parameter (allowing self-loops to be counted).'));if(e=\"\"+e,!this.hasNode(e))throw new U('Graph.degree: could not find the \"'.concat(e,'\" node in the graph.'));var n=0;return\"undirected\"!==this.type&&(n+=this.directedDegree(e,t)),\"directed\"!==this.type&&(n+=this.undirectedDegree(e,t)),n},r.source=function(e){e=\"\"+e;var t=this._edges.get(e);if(!t)throw new U('Graph.source: could not find the \"'.concat(e,'\" edge in the graph.'));return t.source.key},r.target=function(e){e=\"\"+e;var t=this._edges.get(e);if(!t)throw new U('Graph.target: could not find the \"'.concat(e,'\" edge in the graph.'));return t.target.key},r.extremities=function(e){e=\"\"+e;var t=this._edges.get(e);if(!t)throw new U('Graph.extremities: could not find the \"'.concat(e,'\" edge in the graph.'));return[t.source.key,t.target.key]},r.opposite=function(e,t){if(e=\"\"+e,t=\"\"+t,!this._nodes.has(e))throw new U('Graph.opposite: could not find the \"'.concat(e,'\" node in the graph.'));var n=this._edges.get(t);if(!n)throw new U('Graph.opposite: could not find the \"'.concat(t,'\" edge in the graph.'));var r=n.source,i=n.target,o=r.key,a=i.key;if(e!==o&&e!==a)throw new U('Graph.opposite: the \"'.concat(e,'\" node is not attached to the \"').concat(t,'\" edge (').concat(o,\", \").concat(a,\").\"));return e===o?a:o},r.undirected=function(e){e=\"\"+e;var t=this._edges.get(e);if(!t)throw new U('Graph.undirected: could not find the \"'.concat(e,'\" edge in the graph.'));return t instanceof T},r.directed=function(e){e=\"\"+e;var t=this._edges.get(e);if(!t)throw new U('Graph.directed: could not find the \"'.concat(e,'\" edge in the graph.'));return t instanceof C},r.selfLoop=function(e){e=\"\"+e;var t=this._edges.get(e);if(!t)throw new U('Graph.selfLoop: could not find the \"'.concat(e,'\" edge in the graph.'));return t.source===t.target},r.addNode=function(e,t){if(t&&!h(t))throw new j('Graph.addNode: invalid attributes. Expecting an object but got \"'.concat(t,'\"'));if(e=\"\"+e,t=t||{},this._nodes.has(e))throw new z('Graph.addNode: the \"'.concat(e,'\" node already exist in the graph.'));var n=new this.NodeDataClass(e,t);return this._nodes.set(e,n),this.emit(\"nodeAdded\",{key:e,attributes:t}),e},r.mergeNode=function(e,t){if(t&&!h(t))throw new j('Graph.mergeNode: invalid attributes. Expecting an object but got \"'.concat(t,'\"'));e=\"\"+e,t=t||{};var n=this._nodes.get(e);return n?(t&&d(n.attributes,t),e):(n=new this.NodeDataClass(e,t),this._nodes.set(e,n),this.emit(\"nodeAdded\",{key:e,attributes:t}),e)},r.dropNode=function(e){if(e=\"\"+e,!this.hasNode(e))throw new U('Graph.dropNode: could not find the \"'.concat(e,'\" node in the graph.'));for(var t=this.edges(e),n=0,r=t.length;n<r;n++)this.dropEdge(t[n]);var i=this._nodes.get(e);this._nodes.delete(e),this.emit(\"nodeDropped\",{key:e,attributes:i.attributes})},r.dropEdge=function(e){var t;if(arguments.length>1){var n=\"\"+arguments[0],r=\"\"+arguments[1];if(!(t=u(this,n,r,this.type)))throw new U('Graph.dropEdge: could not find the \"'.concat(n,'\" -> \"').concat(r,'\" edge in the graph.'))}else if(e=\"\"+e,!(t=this._edges.get(e)))throw new U('Graph.dropEdge: could not find the \"'.concat(e,'\" edge in the graph.'));this._edges.delete(t.key);var i=t,o=i.source,a=i.target,c=i.attributes,d=t instanceof T;return o===a?o.selfLoops--:d?(o.undirectedDegree--,a.undirectedDegree--):(o.outDegree--,a.inDegree--),W(this,d,t),d?this._undirectedSize--:this._directedSize--,this.emit(\"edgeDropped\",{key:e,attributes:c,source:o.key,target:a.key,undirected:d}),this},r.clear=function(){this._edges.clear(),this._nodes.clear(),this.emit(\"cleared\")},r.clearEdges=function(){this._edges.clear(),this.clearIndex(),this.emit(\"edgesCleared\")},r.getAttribute=function(e){return this._attributes[e]},r.getAttributes=function(){return this._attributes},r.hasAttribute=function(e){return this._attributes.hasOwnProperty(e)},r.setAttribute=function(e,t){return this._attributes[e]=t,this.emit(\"attributesUpdated\",{type:\"set\",meta:{name:e,value:t}}),this},r.updateAttribute=function(e,t){if(\"function\"!=typeof t)throw new j(\"Graph.updateAttribute: updater should be a function.\");return this._attributes[e]=t(this._attributes[e]),this.emit(\"attributesUpdated\",{type:\"set\",meta:{name:e,value:this._attributes[e]}}),this},r.removeAttribute=function(e){return delete this._attributes[e],this.emit(\"attributesUpdated\",{type:\"remove\",meta:{name:e}}),this},r.replaceAttributes=function(e){if(!h(e))throw new j(\"Graph.replaceAttributes: provided attributes are not a plain object.\");var t=this._attributes;return this._attributes=e,this.emit(\"attributesUpdated\",{type:\"replace\",meta:{before:t,after:e}}),this},r.mergeAttributes=function(e){if(!h(e))throw new j(\"Graph.mergeAttributes: provided attributes are not a plain object.\");return this._attributes=d(this._attributes,e),this.emit(\"attributesUpdated\",{type:\"merge\",meta:{data:this._attributes}}),this},r.getNodeAttribute=function(e,t){e=\"\"+e;var n=this._nodes.get(e);if(!n)throw new U('Graph.getNodeAttribute: could not find the \"'.concat(e,'\" node in the graph.'));return n.attributes[t]},r.getNodeAttributes=function(e){e=\"\"+e;var t=this._nodes.get(e);if(!t)throw new U('Graph.getNodeAttributes: could not find the \"'.concat(e,'\" node in the graph.'));return t.attributes},r.hasNodeAttribute=function(e,t){e=\"\"+e;var n=this._nodes.get(e);if(!n)throw new U('Graph.hasNodeAttribute: could not find the \"'.concat(e,'\" node in the graph.'));return n.attributes.hasOwnProperty(t)},r.setNodeAttribute=function(e,t,n){e=\"\"+e;var r=this._nodes.get(e);if(!r)throw new U('Graph.setNodeAttribute: could not find the \"'.concat(e,'\" node in the graph.'));if(arguments.length<3)throw new j(\"Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute's name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.\");return r.attributes[t]=n,this.emit(\"nodeAttributesUpdated\",{key:e,type:\"set\",meta:{name:t,value:n}}),this},r.updateNodeAttribute=function(e,t,n){e=\"\"+e;var r=this._nodes.get(e);if(!r)throw new U('Graph.updateNodeAttribute: could not find the \"'.concat(e,'\" node in the graph.'));if(arguments.length<3)throw new j(\"Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute's name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.\");if(\"function\"!=typeof n)throw new j(\"Graph.updateAttribute: updater should be a function.\");var i=r.attributes;return i[t]=n(i[t]),this.emit(\"nodeAttributesUpdated\",{key:e,type:\"set\",meta:{name:t,value:i[t]}}),this},r.removeNodeAttribute=function(e,t){e=\"\"+e;var n=this._nodes.get(e);if(!n)throw new U('Graph.hasNodeAttribute: could not find the \"'.concat(e,'\" node in the graph.'));return delete n.attributes[t],this.emit(\"nodeAttributesUpdated\",{key:e,type:\"remove\",meta:{name:t}}),this},r.replaceNodeAttributes=function(e,t){e=\"\"+e;var n=this._nodes.get(e);if(!n)throw new U('Graph.replaceNodeAttributes: could not find the \"'.concat(e,'\" node in the graph.'));if(!h(t))throw new j(\"Graph.replaceNodeAttributes: provided attributes are not a plain object.\");var r=n.attributes;return n.attributes=t,this.emit(\"nodeAttributesUpdated\",{key:e,type:\"replace\",meta:{before:r,after:t}}),this},r.mergeNodeAttributes=function(e,t){e=\"\"+e;var n=this._nodes.get(e);if(!n)throw new U('Graph.mergeNodeAttributes: could not find the \"'.concat(e,'\" node in the graph.'));if(!h(t))throw new j(\"Graph.mergeNodeAttributes: provided attributes are not a plain object.\");return d(n.attributes,t),this.emit(\"nodeAttributesUpdated\",{key:e,type:\"merge\",meta:{data:t}}),this},r.forEach=function(e){if(\"function\"!=typeof e)throw new j(\"Graph.forEach: expecting a callback.\");this._edges.forEach((function(t,n){var r=t.source,i=t.target;e(r.key,i.key,r.attributes,i.attributes,n,t.attributes)}))},r.adjacency=function(){var e=this._edges.values();return new N((function(){var t=e.next();if(t.done)return t;var n=t.value,r=n.source,i=n.target;return{done:!1,value:[r.key,i.key,r.attributes,i.attributes,n.key,n.attributes]}}))},r.nodes=function(){return D(this._nodes.keys(),this._nodes.size)},r.forEachNode=function(e){if(\"function\"!=typeof e)throw new j(\"Graph.forEachNode: expecting a callback.\");this._nodes.forEach((function(t,n){e(n,t.attributes)}))},r.nodeEntries=function(){var e=this._nodes.values();return new N((function(){var t=e.next();if(t.done)return t;var n=t.value;return{value:[n.key,n.attributes],done:!1}}))},r.exportNode=function(e){e=\"\"+e;var t=this._nodes.get(e);if(!t)throw new U('Graph.exportNode: could not find the \"'.concat(e,'\" node in the graph.'));return ye(e,t)},r.exportEdge=function(e){e=\"\"+e;var t=this._edges.get(e);if(!t)throw new U('Graph.exportEdge: could not find the \"'.concat(e,'\" edge in the graph.'));return ve(e,t)},r.export=function(){var e=new Array(this._nodes.size),t=0;this._nodes.forEach((function(n,r){e[t++]=ye(r,n)}));var n=new Array(this._edges.size);return t=0,this._edges.forEach((function(e,r){n[t++]=ve(r,e)})),{attributes:this.getAttributes(),nodes:e,edges:n}},r.importNode=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=we(e);if(n){if(\"not-object\"===n)throw new j('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');if(\"no-key\"===n)throw new j(\"Graph.importNode: no key provided.\");if(\"invalid-attributes\"===n)throw new j(\"Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.\")}var r=e.key,i=e.attributes,o=void 0===i?{}:i;return t?this.mergeNode(r,o):this.addNode(r,o),this},r.importEdge=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=be(e);if(n){if(\"not-object\"===n)throw new j('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');if(\"no-source\"===n)throw new j(\"Graph.importEdge: missing souce.\");if(\"no-target\"===n)throw new j(\"Graph.importEdge: missing target.\");if(\"invalid-attributes\"===n)throw new j(\"Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.\");if(\"invalid-undirected\"===n)throw new j(\"Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.\")}var r=e.source,i=e.target,o=e.attributes,a=void 0===o?{}:o,c=e.undirected,d=void 0!==c&&c;return\"key\"in e?(t?d?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:d?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,e.key,r,i,a):(t?d?this.mergeUndirectedEdge:this.mergeDirectedEdge:d?this.addUndirectedEdge:this.addDirectedEdge).call(this,r,i,a),this},r.import=function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(s(e))return this.import(e.export(),n),this;if(!h(e))throw new j(\"Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.\");if(e.attributes){if(!h(e.attributes))throw new j(\"Graph.import: invalid attributes. Expecting a plain object.\");n?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}return e.nodes&&e.nodes.forEach((function(e){return t.importNode(e,n)})),e.edges&&e.edges.forEach((function(e){return t.importEdge(e,n)})),this},r.nullCopy=function(e){return new n(d({},this._options,e))},r.emptyCopy=function(e){var t=new n(d({},this._options,e));return this._nodes.forEach((function(e,n){e=new t.NodeDataClass(n,d({},e.attributes)),t._nodes.set(n,e)})),t},r.copy=function(){var e=new n(this._options);return e.import(this),e},r.upgradeToMixed=function(){return\"mixed\"===this.type||(this._nodes.forEach((function(e){return e.upgradeToMixed()})),this._options.type=\"mixed\",g(this,\"type\",this._options.type),p(this,\"NodeDataClass\",O)),this},r.upgradeToMulti=function(){return this.multi||(this._options.multi=!0,g(this,\"multi\",!0),(e=this)._nodes.forEach((function(t,n){if(t.out)for(var r in t.out){var i=new Set;i.add(t.out[r]),t.out[r]=i,e._nodes.get(r).in[n]=i}if(t.undirected)for(var o in t.undirected)if(!(o>n)){var a=new Set;a.add(t.undirected[o]),t.undirected[o]=a,e._nodes.get(o).undirected[n]=a}}))),this;var e},r.clearIndex=function(){return this._nodes.forEach((function(e){void 0!==e.in&&(e.in={},e.out={}),void 0!==e.undirected&&(e.undirected={})})),this},r.toJSON=function(){return this.export()},r.toString=function(){var e=this.order>1||0===this.order,t=this.size>1||0===this.size;return\"Graph<\".concat(f(this.order),\" node\").concat(e?\"s\":\"\",\", \").concat(f(this.size),\" edge\").concat(t?\"s\":\"\",\">\")},r.inspect=function(){var e=this,t={};this._nodes.forEach((function(e,n){t[n]=e.attributes}));var n={},r={};this._edges.forEach((function(t,i){var o=t instanceof T?\"--\":\"->\",a=\"\",c=\"(\".concat(t.source.key,\")\").concat(o,\"(\").concat(t.target.key,\")\");t.generatedKey?e.multi&&(void 0===r[c]?r[c]=0:r[c]++,a+=\"\".concat(r[c],\". \")):a+=\"[\".concat(i,\"]: \"),n[a+=c]=t.attributes}));var i={};for(var o in this)this.hasOwnProperty(o)&&!_e.has(o)&&\"function\"!=typeof this[o]&&(i[o]=this[o]);return i.attributes=this._attributes,i.nodes=t,i.edges=n,p(i,\"constructor\",this.constructor),i},n}(y);\"undefined\"!=typeof Symbol&&(xe.prototype[Symbol.for(\"nodejs.util.inspect.custom\")]=xe.prototype.inspect),[{name:function(e){return\"\".concat(e,\"Edge\")},generateKey:!0},{name:function(e){return\"\".concat(e,\"DirectedEdge\")},generateKey:!0,type:\"directed\"},{name:function(e){return\"\".concat(e,\"UndirectedEdge\")},generateKey:!0,type:\"undirected\"},{name:function(e){return\"\".concat(e,\"EdgeWithKey\")}},{name:function(e){return\"\".concat(e,\"DirectedEdgeWithKey\")},type:\"directed\"},{name:function(e){return\"\".concat(e,\"UndirectedEdgeWithKey\")},type:\"undirected\"}].forEach((function(e){[\"add\",\"merge\"].forEach((function(t){var n=e.name(t),r=\"add\"===t?Ee:ke;e.generateKey?xe.prototype[n]=function(t,i,o){return r(this,n,!0,\"undirected\"===(e.type||this.type),null,t,i,o)}:xe.prototype[n]=function(t,i,o,a){return r(this,n,!1,\"undirected\"===(e.type||this.type),t,i,o,a)}}))})),\"undefined\"!=typeof Symbol&&(xe.prototype[Symbol.iterator]=xe.prototype.adjacency),function(e){R.forEach((function(t){var n=t.name,r=t.attacher;r(e,n(\"Edge\"),\"mixed\",C),r(e,n(\"DirectedEdge\"),\"directed\",C),r(e,n(\"UndirectedEdge\"),\"undirected\",T)}))}(xe),function(e){F.forEach((function(t){!function(e,t){var n=t.name,r=t.type,i=t.direction;e.prototype[n]=function(e,t){if(\"mixed\"!==r&&\"mixed\"!==this.type&&r!==this.type)return[];if(!arguments.length)return X(this,r);if(1===arguments.length){e=\"\"+e;var o=this._nodes.get(e);if(void 0===o)throw new U(\"Graph.\".concat(n,': could not find the \"').concat(e,'\" node in the graph.'));return ee(\"mixed\"===r?this.type:r,i,o)}if(2===arguments.length){e=\"\"+e,t=\"\"+t;var a=this._nodes.get(e);if(!a)throw new U(\"Graph.\".concat(n,':  could not find the \"').concat(e,'\" source node in the graph.'));if(!this._nodes.has(t))throw new U(\"Graph.\".concat(n,':  could not find the \"').concat(t,'\" target node in the graph.'));return re(r,i,a,t)}throw new j(\"Graph.\".concat(n,\": too many arguments (expecting 0, 1 or 2 and got \").concat(arguments.length,\").\"))}}(e,t),function(e,t){var n=t.name,r=t.type,i=t.direction,o=\"forEach\"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t,n){if(\"mixed\"===r||\"mixed\"===this.type||r===this.type){if(1===arguments.length)return Z(this,r,n=e);if(2===arguments.length){e=\"\"+e,n=t;var a=this._nodes.get(e);if(void 0===a)throw new U(\"Graph.\".concat(o,': could not find the \"').concat(e,'\" node in the graph.'));return te(this.multi,\"mixed\"===r?this.type:r,i,a,n)}if(3===arguments.length){e=\"\"+e,t=\"\"+t;var c=this._nodes.get(e);if(!c)throw new U(\"Graph.\".concat(o,':  could not find the \"').concat(e,'\" source node in the graph.'));if(!this._nodes.has(t))throw new U(\"Graph.\".concat(o,':  could not find the \"').concat(t,'\" target node in the graph.'));return ie(r,i,c,t,n)}throw new j(\"Graph.\".concat(o,\": too many arguments (expecting 1, 2 or 3 and got \").concat(arguments.length,\").\"))}}}(e,t),function(e,t){var n=t.name,r=t.type,i=t.direction,o=n.slice(0,-1)+\"Entries\";e.prototype[o]=function(e,t){if(\"mixed\"!==r&&\"mixed\"!==this.type&&r!==this.type)return N.empty();if(!arguments.length)return $(this,r);if(1===arguments.length){e=\"\"+e;var n=this._nodes.get(e);if(!n)throw new U(\"Graph.\".concat(o,': could not find the \"').concat(e,'\" node in the graph.'));return ne(r,i,n)}if(2===arguments.length){e=\"\"+e,t=\"\"+t;var a=this._nodes.get(e);if(!a)throw new U(\"Graph.\".concat(o,':  could not find the \"').concat(e,'\" source node in the graph.'));if(!this._nodes.has(t))throw new U(\"Graph.\".concat(o,':  could not find the \"').concat(t,'\" target node in the graph.'));return oe(r,i,a,t)}throw new j(\"Graph.\".concat(o,\": too many arguments (expecting 0, 1 or 2 and got \").concat(arguments.length,\").\"))}}(e,t)}))}(xe),function(e){ae.forEach((function(t){!function(e,t){var n=t.name,r=t.type,i=t.direction;e.prototype[n]=function(e){if(\"mixed\"!==r&&\"mixed\"!==this.type&&r!==this.type)return[];if(2===arguments.length){var t=\"\"+arguments[0],o=\"\"+arguments[1];if(!this._nodes.has(t))throw new U(\"Graph.\".concat(n,': could not find the \"').concat(t,'\" node in the graph.'));if(!this._nodes.has(o))throw new U(\"Graph.\".concat(n,': could not find the \"').concat(o,'\" node in the graph.'));return pe(this,r,i,t,o)}if(1===arguments.length){e=\"\"+e;var a=this._nodes.get(e);if(void 0===a)throw new U(\"Graph.\".concat(n,': could not find the \"').concat(e,'\" node in the graph.'));var c=de(\"mixed\"===r?this.type:r,i,a);return c}throw new j(\"Graph.\".concat(n,\": invalid number of arguments (expecting 1 or 2 and got \").concat(arguments.length,\").\"))}}(e,t),ge(e,t),le(e,t)}))}(xe);var Se=function(e){function n(t){return e.call(this,d({type:\"directed\"},t))||this}return t(n,e),n}(xe),Ae=function(e){function n(t){return e.call(this,d({type:\"undirected\"},t))||this}return t(n,e),n}(xe),Ne=function(e){function n(t){return e.call(this,d({multi:!0},t))||this}return t(n,e),n}(xe),De=function(e){function n(t){return e.call(this,d({multi:!0,type:\"directed\"},t))||this}return t(n,e),n}(xe),Le=function(e){function n(t){return e.call(this,d({multi:!0,type:\"undirected\"},t))||this}return t(n,e),n}(xe);function je(e){e.from=function(t,n){var r=new e(n);return r.import(t),r}}return je(xe),je(Se),je(Ae),je(Ne),je(De),je(Le),xe.Graph=xe,xe.DirectedGraph=Se,xe.UndirectedGraph=Ae,xe.MultiGraph=Ne,xe.MultiDirectedGraph=De,xe.MultiUndirectedGraph=Le,xe.InvalidArgumentsGraphError=j,xe.NotFoundGraphError=U,xe.UsageGraphError=z,xe}));\n//# sourceMappingURL=graphology.umd.min.js.map\n\n\n//# sourceURL=webpack:///./node_modules/graphology/dist/graphology.umd.min.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/sigma/camera.js":
/*!**************************************!*\
  !*** ./node_modules/sigma/camera.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar easings = _interopRequireWildcard(__webpack_require__(/*! ./easings */ \"./node_modules/sigma/easings.js\"));\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./node_modules/sigma/utils.js\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Defaults.\n */\nvar ANIMATE_DEFAULTS = {\n  easing: 'quadraticInOut',\n  duration: 150\n};\nvar DEFAULT_ZOOMING_RATIO = 1.5; // TODO: animate options = number polymorphism?\n// TODO: pan, zoom, unzoom, reset, rotate, zoomTo\n// TODO: add width / height to camera and add #.resize\n// TODO: bind camera to renderer rather than sigma\n// TODO: add #.graphToDisplay, #.displayToGraph, batch methods later\n\n/**\n * Camera class\n *\n * @constructor\n */\n\nvar Camera =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Camera, _EventEmitter);\n\n  function Camera() {\n    var _this;\n\n    _classCallCheck(this, Camera);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Camera).call(this)); // Properties\n\n    _this.x = 0.5;\n    _this.y = 0.5;\n    _this.angle = 0;\n    _this.ratio = 1; // State\n\n    _this.nextFrame = null;\n    _this.previousState = _this.getState();\n    _this.enabled = true;\n    return _this;\n  }\n  /**\n   * Method used to enable the camera.\n   *\n   * @return {Camera}\n   */\n\n\n  _createClass(Camera, [{\n    key: \"enable\",\n    value: function enable() {\n      this.enabled = true;\n      return this;\n    }\n    /**\n     * Method used to disable the camera.\n     *\n     * @return {Camera}\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n    /**\n     * Method used to retrieve the camera's current state.\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n    /**\n     * Method used to retrieve the camera's previous state.\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n    /**\n     * Method used to check whether the camera is currently being animated.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n    /**\n     * Method returning the coordinates of a point from the graph frame to the\n     * viewport.\n     *\n     * @param  {object} dimensions - Dimensions of the viewport.\n     * @param  {number} x          - The X coordinate.\n     * @param  {number} y          - The Y coordinate.\n     * @return {object}            - The point coordinates in the viewport.\n     */\n    // TODO: assign to gain one object\n    // TODO: angles\n\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(dimensions, x, y) {\n      var smallestDimension = Math.min(dimensions.width, dimensions.height);\n      var dx = smallestDimension / dimensions.width,\n          dy = smallestDimension / dimensions.height; // TODO: we keep on the upper left corner!\n      // TODO: how to normalize sizes?\n\n      return {\n        x: (x - this.x + this.ratio / 2 / dx) * (smallestDimension / this.ratio),\n        y: (this.y - y + this.ratio / 2 / dy) * (smallestDimension / this.ratio)\n      };\n    }\n    /**\n     * Method returning the coordinates of a point from the viewport frame to the\n     * graph frame.\n     *\n     * @param  {object} dimensions - Dimensions of the viewport.\n     * @param  {number} x          - The X coordinate.\n     * @param  {number} y          - The Y coordinate.\n     * @return {object}            - The point coordinates in the graph frame.\n     */\n    // TODO: angles\n\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(dimensions, x, y) {\n      var smallestDimension = Math.min(dimensions.width, dimensions.height);\n      var dx = smallestDimension / dimensions.width,\n          dy = smallestDimension / dimensions.height;\n      return {\n        x: this.ratio / smallestDimension * x + this.x - this.ratio / 2 / dx,\n        y: -(this.ratio / smallestDimension * y - this.y - this.ratio / 2 / dy)\n      };\n    }\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n    // TODO: angle\n\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle(dimensions) {\n      // TODO: reduce relative margin?\n      var marginX = 0 * dimensions.width / 8,\n          marginY = 0 * dimensions.height / 8;\n      var p1 = this.viewportToGraph(dimensions, 0 - marginX, 0 - marginY),\n          p2 = this.viewportToGraph(dimensions, dimensions.width + marginX, 0 - marginY),\n          h = this.viewportToGraph(dimensions, 0, dimensions.height + marginY);\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n    /**\n     * Method used to set the camera's state.\n     *\n     * @param  {object} state - New state.\n     * @return {Camera}\n     */\n\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this; // TODO: validations\n      // TODO: update by function\n      // Keeping track of last state\n\n      this.previousState = this.getState();\n      if ('x' in state) this.x = state.x;\n      if ('y' in state) this.y = state.y;\n      if ('angle' in state) this.angle = state.angle;\n      if ('ratio' in state) this.ratio = state.ratio; // Emitting\n      // TODO: don't emit if nothing changed?\n\n      this.emit('updated', this.getState());\n      return this;\n    }\n    /**\n     * Method used to animate the camera.\n     *\n     * @param  {object}   state      - State to reach eventually.\n     * @param  {object}   options    - Options:\n     * @param  {number}     duration - Duration of the animation.\n     * @param  {function} callback   - Callback\n     * @return {function}            - Return a function to cancel the animation.\n     */\n\n  }, {\n    key: \"animate\",\n    value: function animate(state, options, callback) {\n      var _this2 = this;\n\n      if (!this.enabled) return this; // TODO: validation\n\n      options = (0, _utils.assign)({}, ANIMATE_DEFAULTS, options);\n      var easing = typeof options.easing === 'function' ? options.easing : easings[options.easing]; // Canceling previous animation if needed\n\n      if (this.nextFrame) cancelAnimationFrame(this.nextFrame); // State\n\n      var start = Date.now(),\n          initialState = this.getState(); // Function performing the animation\n\n      var fn = function fn() {\n        var t = (Date.now() - start) / options.duration; // The animation is over:\n\n        if (t >= 1) {\n          _this2.nextFrame = null;\n\n          _this2.setState(state);\n\n          if (typeof callback === 'function') callback();\n          return;\n        }\n\n        var coefficient = easing(t);\n        var newState = {};\n        if ('x' in state) newState.x = initialState.x + (state.x - initialState.x) * coefficient;\n        if ('y' in state) newState.y = initialState.y + (state.y - initialState.y) * coefficient;\n        if ('angle' in state) newState.angle = initialState.angle + (state.angle - initialState.angle) * coefficient;\n        if ('ratio' in state) newState.ratio = initialState.ratio + (state.ratio - initialState.ratio) * coefficient;\n\n        _this2.setState(newState);\n\n        _this2.nextFrame = requestAnimationFrame(fn);\n      };\n\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        this.nextFrame = requestAnimationFrame(fn);\n      } else {\n        fn();\n      }\n    }\n    /**\n     * Method used to zoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     * @return {function}\n     */\n\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        return this.animate({\n          ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === 'number') return this.animate({\n          ratio: this.ratio / factorOrOptions\n        });else return this.animate({\n          ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n    /**\n     * Method used to unzoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     * @return {function}\n     */\n\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        return this.animate({\n          ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === 'number') return this.animate({\n          ratio: this.ratio * factorOrOptions\n        });else return this.animate({\n          ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n    /**\n     * Method used to reset the camera.\n     *\n     * @param  {object} options - Options.\n     * @return {function}\n     */\n\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      return this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n  }]);\n\n  return Camera;\n}(_events.EventEmitter);\n\nexports[\"default\"] = Camera;\n\n//# sourceURL=webpack:///./node_modules/sigma/camera.js?");

/***/ }),

/***/ "./node_modules/sigma/captor.js":
/*!**************************************!*\
  !*** ./node_modules/sigma/captor.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Captor =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Captor, _EventEmitter);\n\n  function Captor(container, camera) {\n    var _this;\n\n    _classCallCheck(this, Captor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Captor).call(this)); // Properties\n\n    _this.container = container;\n    _this.camera = camera;\n    return _this;\n  }\n\n  return Captor;\n}(_events.EventEmitter);\n\nexports[\"default\"] = Captor;\n\n//# sourceURL=webpack:///./node_modules/sigma/captor.js?");

/***/ }),

/***/ "./node_modules/sigma/captors/mouse.js":
/*!*********************************************!*\
  !*** ./node_modules/sigma/captors/mouse.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _camera = _interopRequireDefault(__webpack_require__(/*! ../camera */ \"./node_modules/sigma/camera.js\"));\n\nvar _captor = _interopRequireDefault(__webpack_require__(/*! ../captor */ \"./node_modules/sigma/captor.js\"));\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./node_modules/sigma/captors/utils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Constants.\n */\nvar DRAG_TIMEOUT = 200,\n    MOUSE_INERTIA_DURATION = 200,\n    MOUSE_INERTIA_RATIO = 3,\n    MOUSE_ZOOM_DURATION = 200,\n    ZOOMING_RATIO = 1.7,\n    DOUBLE_CLICK_TIMEOUT = 300,\n    DOUBLE_CLICK_ZOOMING_RATIO = 2.2,\n    DOUBLE_CLICK_ZOOMING_DURATION = 200;\n/**\n * Mouse captor class.\n *\n * @constructor\n */\n\nvar MouseCaptor =\n/*#__PURE__*/\nfunction (_Captor) {\n  _inherits(MouseCaptor, _Captor);\n\n  function MouseCaptor(container, camera) {\n    var _this;\n\n    _classCallCheck(this, MouseCaptor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MouseCaptor).call(this, container, camera)); // Properties\n\n    _this.container = container;\n    _this.camera = camera; // State\n\n    _this.enabled = true;\n    _this.hasDragged = false;\n    _this.downStartTime = null;\n    _this.lastMouseX = null;\n    _this.lastMouseY = null;\n    _this.isMouseDown = false;\n    _this.isMoving = false;\n    _this.movingTimeout = null;\n    _this.startCameraState = null;\n    _this.lastCameraState = null;\n    _this.clicks = 0;\n    _this.doubleClickTimeout = null;\n    _this.wheelLock = false; // Binding methods\n\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));\n    _this.handleDown = _this.handleDown.bind(_assertThisInitialized(_this));\n    _this.handleUp = _this.handleUp.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n    _this.handleWheel = _this.handleWheel.bind(_assertThisInitialized(_this));\n    _this.handleOut = _this.handleOut.bind(_assertThisInitialized(_this)); // Binding events\n\n    container.addEventListener('click', _this.handleClick, false);\n    container.addEventListener('mousedown', _this.handleDown, false);\n    container.addEventListener('mousemove', _this.handleMove, false);\n    container.addEventListener('DOMMouseScroll', _this.handleWheel, false);\n    container.addEventListener('mousewheel', _this.handleWheel, false);\n    container.addEventListener('mouseout', _this.handleOut, false);\n    document.addEventListener('mouseup', _this.handleUp, false);\n    return _this;\n  }\n\n  _createClass(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener('click', this.handleClick);\n      container.removeEventListener('mousedown', this.handleDown);\n      container.removeEventListener('mousemove', this.handleMove);\n      container.removeEventListener('DOMMouseScroll', this.handleWheel);\n      container.removeEventListener('mousewheel', this.handleWheel);\n      container.removeEventListener('mouseout', this.handleOut);\n      document.removeEventListener('mouseup', this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n\n      if (!this.enabled) return;\n      this.clicks++;\n\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        clearTimeout(this.doubleClickTimeout);\n        this.doubleClickTimeout = null;\n        return this.handleDoubleClick(e);\n      }\n\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, DOUBLE_CLICK_TIMEOUT); // NOTE: this is here to prevent click events on drag\n\n      if (!this.hasDragged) this.emit('click', (0, _utils.getMouseCoords)(e));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      var center = (0, _utils.getCenter)(e);\n      var cameraState = this.camera.getState();\n      var newRatio = cameraState.ratio / DOUBLE_CLICK_ZOOMING_RATIO; // TODO: factorize\n\n      var dimensions = {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n      var clickX = (0, _utils.getX)(e),\n          clickY = (0, _utils.getY)(e); // TODO: baaaad we mustn't mutate the camera, create a Camera.from or #.copy\n      // TODO: factorize pan & zoomTo\n\n      var cameraWithNewRatio = new _camera[\"default\"]();\n      cameraWithNewRatio.ratio = newRatio;\n      cameraWithNewRatio.x = cameraState.x;\n      cameraWithNewRatio.y = cameraState.y;\n      var clickGraph = this.camera.viewportToGraph(dimensions, clickX, clickY),\n          centerGraph = this.camera.viewportToGraph(dimensions, center.x, center.y);\n      var clickGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, clickX, clickY),\n          centerGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, center.x, center.y);\n      var deltaX = clickGraphNew.x - centerGraphNew.x - clickGraph.x + centerGraph.x,\n          deltaY = clickGraphNew.y - centerGraphNew.y - clickGraph.y + centerGraph.y;\n      this.camera.animate({\n        x: cameraState.x - deltaX,\n        y: cameraState.y - deltaY,\n        ratio: newRatio\n      }, {\n        easing: 'quadraticInOut',\n        duration: DOUBLE_CLICK_ZOOMING_DURATION\n      });\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      e.stopPropagation();\n      return false;\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n      this.startCameraState = this.camera.getState();\n      this.lastCameraState = this.startCameraState;\n      this.lastMouseX = (0, _utils.getX)(e);\n      this.lastMouseY = (0, _utils.getY)(e);\n      this.hasDragged = false;\n      this.downStartTime = Date.now(); // TODO: dispatch events\n\n      switch (e.which) {\n        default:\n          // Left button pressed\n          this.isMouseDown = true;\n          this.emit('mousedown', (0, _utils.getMouseCoords)(e));\n      }\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n\n      if (!this.enabled || !this.isMouseDown) return;\n      this.isMouseDown = false;\n\n      if (this.movingTimeout) {\n        this.movingTimeout = null;\n        clearTimeout(this.movingTimeout);\n      }\n\n      var x = (0, _utils.getX)(e),\n          y = (0, _utils.getY)(e);\n      var cameraState = this.camera.getState(),\n          previousCameraState = this.camera.getPreviousState();\n\n      if (this.isMoving) {\n        this.camera.animate({\n          x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: MOUSE_INERTIA_DURATION,\n          easing: 'quadraticOut'\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        this.camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n\n      this.isMoving = false;\n      setImmediate(function () {\n        return _this3.hasDragged = false;\n      });\n      this.emit('mouseup', (0, _utils.getMouseCoords)(e));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n\n      if (!this.enabled) return;\n      this.emit('mousemove', (0, _utils.getMouseCoords)(e));\n\n      if (this.isMouseDown) {\n        // TODO: dispatch events\n        this.isMoving = true;\n        this.hasDragged = true;\n        if (this.movingTimeout) clearTimeout(this.movingTimeout);\n        this.movingTimeout = setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, DRAG_TIMEOUT);\n        var dimensions = {\n          width: this.container.offsetWidth,\n          height: this.container.offsetHeight\n        };\n        var eX = (0, _utils.getX)(e),\n            eY = (0, _utils.getY)(e);\n        var lastMouse = this.camera.viewportToGraph(dimensions, this.lastMouseX, this.lastMouseY);\n        var mouse = this.camera.viewportToGraph(dimensions, eX, eY);\n        var offsetX = lastMouse.x - mouse.x,\n            offsetY = lastMouse.y - mouse.y;\n        var cameraState = this.camera.getState();\n        var x = cameraState.x + offsetX,\n            y = cameraState.y + offsetY;\n        this.camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n      }\n\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      e.stopPropagation();\n      return false;\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      e.stopPropagation();\n      if (!this.enabled) return false;\n      var delta = (0, _utils.getWheelDelta)(e);\n      if (!delta) return false;\n      if (this.wheelLock) return false;\n      this.wheelLock = true; // TODO: handle max zoom\n\n      var ratio = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;\n      var cameraState = this.camera.getState();\n      var newRatio = ratio * cameraState.ratio;\n      var center = (0, _utils.getCenter)(e);\n      var dimensions = {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n      var clickX = (0, _utils.getX)(e),\n          clickY = (0, _utils.getY)(e); // TODO: baaaad we mustn't mutate the camera, create a Camera.from or #.copy\n      // TODO: factorize pan & zoomTo\n\n      var cameraWithNewRatio = new _camera[\"default\"]();\n      cameraWithNewRatio.ratio = newRatio;\n      cameraWithNewRatio.x = cameraState.x;\n      cameraWithNewRatio.y = cameraState.y;\n      var clickGraph = this.camera.viewportToGraph(dimensions, clickX, clickY),\n          centerGraph = this.camera.viewportToGraph(dimensions, center.x, center.y);\n      var clickGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, clickX, clickY),\n          centerGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, center.x, center.y);\n      var deltaX = clickGraphNew.x - centerGraphNew.x - clickGraph.x + centerGraph.x,\n          deltaY = clickGraphNew.y - centerGraphNew.y - clickGraph.y + centerGraph.y;\n      this.camera.animate({\n        x: cameraState.x - deltaX,\n        y: cameraState.y - deltaY,\n        ratio: newRatio\n      }, {\n        easing: 'linear',\n        duration: MOUSE_ZOOM_DURATION\n      }, function () {\n        return _this5.wheelLock = false;\n      });\n      return false;\n    }\n  }, {\n    key: \"handleOut\",\n    value: function handleOut() {// TODO: dispatch event\n    }\n  }]);\n\n  return MouseCaptor;\n}(_captor[\"default\"]);\n\nexports[\"default\"] = MouseCaptor;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/sigma/captors/mouse.js?");

/***/ }),

/***/ "./node_modules/sigma/captors/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/sigma/captors/utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getX = getX;\nexports.getY = getY;\nexports.getWidth = getWidth;\nexports.getHeight = getHeight;\nexports.getCenter = getCenter;\nexports.getMouseCoords = getMouseCoords;\nexports.getWheelDelta = getWheelDelta;\n\nvar _utils = __webpack_require__(/*! ../renderers/utils */ \"./node_modules/sigma/renderers/utils.js\");\n\n/**\n * Sigma.js Captor Utils\n * ======================\n *\n * Miscellenous helper functions related to the captors.\n */\n\n/**\n * Extract the local X position from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The local X value of the mouse.\n */\nfunction getX(e) {\n  if (typeof e.offsetX !== 'undefined') return e.offsetX;\n  if (typeof e.layerX !== 'undefined') return e.layerX;\n  if (typeof e.clientX !== 'undefined') return e.clientX;\n  throw new Error('sigma/captors/utils.getX: could not extract x from event.');\n}\n/**\n * Extract the local Y position from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The local Y value of the mouse.\n */\n\n\nfunction getY(e) {\n  if (typeof e.offsetY !== 'undefined') return e.offsetY;\n  if (typeof e.layerY !== 'undefined') return e.layerY;\n  if (typeof e.clientY !== 'undefined') return e.clientY;\n  throw new Error('sigma/captors/utils.getY: could not extract y from event.');\n}\n/**\n * Extract the width from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The width of the event's target.\n */\n\n\nfunction getWidth(e) {\n  var w = !e.target.ownerSVGElement ? e.target.width : e.target.ownerSVGElement.width;\n  if (typeof w === 'number') return w;\n  if (w !== undefined && w.baseVal !== undefined) return w.baseVal.value;\n  throw new Error('sigma/captors/utils.getWidth: could not extract width from event.');\n}\n/**\n * Extract the height from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The height of the event's target.\n */\n\n\nfunction getHeight(e) {\n  var w = !e.target.ownerSVGElement ? e.target.height : e.target.ownerSVGElement.height;\n  if (typeof w === 'number') return w;\n  if (w !== undefined && w.baseVal !== undefined) return w.baseVal.value;\n  throw new Error('sigma/captors/utils.getHeight: could not extract height from event.');\n}\n/**\n * Extract the center from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {object}     The center of the event's target.\n */\n\n\nfunction getCenter(e) {\n  var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 : (0, _utils.getPixelRatio)();\n  return {\n    x: getWidth(e) / (2 * ratio),\n    y: getHeight(e) / (2 * ratio)\n  };\n}\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}   e   - A mouse or touch event.\n * @param  {number}  [x] - The x coord to convert\n * @param  {number}  [y] - The y coord to convert\n *\n * @return {object}\n */\n\n\nfunction getMouseCoords(e) {\n  return {\n    x: getX(e),\n    y: getY(e),\n    clientX: e.clientX,\n    clientY: e.clientY,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    shiftKey: e.shiftKey\n  };\n}\n/**\n * Extract the wheel delta from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The wheel delta of the mouse.\n */\n\n\nfunction getWheelDelta(e) {\n  if (typeof e.wheelDelta !== 'undefined') return e.wheelDelta / 360;\n  if (typeof e.detail !== 'undefined') return e.detail / -9;\n  throw new Error('sigma/captors/utils.getDelta: could not extract delta from event.');\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/captors/utils.js?");

/***/ }),

/***/ "./node_modules/sigma/easings.js":
/*!***************************************!*\
  !*** ./node_modules/sigma/easings.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cubicInOut = exports.cubicOut = exports.cubicIn = exports.quadraticInOut = exports.quadraticOut = exports.quadraticIn = exports.linear = void 0;\n\n/**\n * Sigma.js Easings\n * =================\n *\n * Handy collection of easing functions.\n */\nvar linear = function linear(k) {\n  return k;\n};\n\nexports.linear = linear;\n\nvar quadraticIn = function quadraticIn(k) {\n  return k * k;\n};\n\nexports.quadraticIn = quadraticIn;\n\nvar quadraticOut = function quadraticOut(k) {\n  return k * (2 - k);\n};\n\nexports.quadraticOut = quadraticOut;\n\nvar quadraticInOut = function quadraticInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k;\n  return -0.5 * (--k * (k - 2) - 1);\n};\n\nexports.quadraticInOut = quadraticInOut;\n\nvar cubicIn = function cubicIn(k) {\n  return k * k * k;\n};\n\nexports.cubicIn = cubicIn;\n\nvar cubicOut = function cubicOut(k) {\n  return --k * k * k + 1;\n};\n\nexports.cubicOut = cubicOut;\n\nvar cubicInOut = function cubicInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k * k;\n  return 0.5 * ((k -= 2) * k * k + 2);\n};\n\nexports.cubicInOut = cubicInOut;\n\n//# sourceURL=webpack:///./node_modules/sigma/easings.js?");

/***/ }),

/***/ "./node_modules/sigma/endpoint.js":
/*!****************************************!*\
  !*** ./node_modules/sigma/endpoint.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Renderer\", {\n  enumerable: true,\n  get: function get() {\n    return _renderer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"Camera\", {\n  enumerable: true,\n  get: function get() {\n    return _camera[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"QuadTree\", {\n  enumerable: true,\n  get: function get() {\n    return _quadtree[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"MouseCaptor\", {\n  enumerable: true,\n  get: function get() {\n    return _mouse[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"WebGLRenderer\", {\n  enumerable: true,\n  get: function get() {\n    return _webgl[\"default\"];\n  }\n});\n\nvar _renderer = _interopRequireDefault(__webpack_require__(/*! ./renderer */ \"./node_modules/sigma/renderer.js\"));\n\nvar _camera = _interopRequireDefault(__webpack_require__(/*! ./camera */ \"./node_modules/sigma/camera.js\"));\n\nvar _quadtree = _interopRequireDefault(__webpack_require__(/*! ./quadtree */ \"./node_modules/sigma/quadtree.js\"));\n\nvar _mouse = _interopRequireDefault(__webpack_require__(/*! ./captors/mouse */ \"./node_modules/sigma/captors/mouse.js\"));\n\nvar _webgl = _interopRequireDefault(__webpack_require__(/*! ./renderers/webgl */ \"./node_modules/sigma/renderers/webgl/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n//# sourceURL=webpack:///./node_modules/sigma/endpoint.js?");

/***/ }),

/***/ "./node_modules/sigma/heuristics/labels.js":
/*!*************************************************!*\
  !*** ./node_modules/sigma/heuristics/labels.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelsToDisplayFromGrid = labelsToDisplayFromGrid;\nexports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;\n\nvar _camera = _interopRequireDefault(__webpack_require__(/*! ../camera */ \"./node_modules/sigma/camera.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscelleneous heuristics related to label display.\n */\n\n/**\n * Constants.\n */\n// Dimensions of a normal cell\nvar DEFAULT_CELL = {\n  width: 250,\n  height: 175\n}; // Dimensions of an unzoomed cell. This one is usually larger than the normal\n// one to account for the fact that labels will more likely collide.\n\nvar DEFAULT_UNZOOMED_CELL = {\n  width: 400,\n  height: 300\n};\n/**\n * Helpers.\n */\n\nfunction collision(x1, y1, w1, h1, x2, y2, w2, h2) {\n  return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;\n} // TODO: cache camera position of selected nodes to avoid costly computations\n// in anti-collision step\n// TOOD: document a little bit more so future people can understand this mess\n\n/**\n * Label grid heuristic selecting labels to display.\n *\n * @param  {object} params                 - Parameters:\n * @param  {object}   cache                - Cache storing nodes' data.\n * @param  {Camera}   camera               - The renderer's camera.\n * @param  {Set}      displayedLabels      - Currently displayed labels.\n * @param  {Array}    visibleNodes         - Nodes visible for this render.\n * @param  {Graph}    graph                - The rendered graph.\n * @return {Array}                         - The selected labels.\n */\n\n\nfunction labelsToDisplayFromGrid(params) {\n  var cache = params.cache,\n      camera = params.camera,\n      userCell = params.cell,\n      dimensions = params.dimensions,\n      displayedLabels = params.displayedLabels,\n      _params$fontSize = params.fontSize,\n      fontSize = _params$fontSize === void 0 ? 14 : _params$fontSize,\n      graph = params.graph,\n      _params$renderedSizeT = params.renderedSizeThreshold,\n      renderedSizeThreshold = _params$renderedSizeT === void 0 ? -Infinity : _params$renderedSizeT,\n      visibleNodes = params.visibleNodes;\n  var cameraState = camera.getState(),\n      previousCameraState = camera.getPreviousState();\n  var previousCamera = new _camera[\"default\"]();\n  previousCamera.setState(previousCameraState); // TODO: should factorize. This same code is used quite a lot throughout the codebase\n  // TODO: POW RATIO is currently default 0.5 and harcoded\n\n  var sizeRatio = Math.pow(cameraState.ratio, 0.5); // Camera hasn't moved?\n\n  var still = cameraState.x === previousCameraState.x && cameraState.y === previousCameraState.y && cameraState.ratio === previousCameraState.ratio; // State\n\n  var zooming = cameraState.ratio < previousCameraState.ratio,\n      panning = cameraState.x !== previousCameraState.x || cameraState.y !== previousCameraState.y,\n      unzooming = cameraState.ratio > previousCameraState.ratio,\n      unzoomedPanning = !zooming && !unzooming && cameraState.ratio >= 1,\n      zoomedPanning = panning && displayedLabels.size && !zooming && !unzooming; // Trick to discretize unzooming\n\n  if (unzooming && Math.trunc(cameraState.ratio * 100) % 5 !== 0) return Array.from(displayedLabels); // If panning while unzoomed, we shouldn't change label selection\n\n  if ((unzoomedPanning || still) && displayedLabels.size !== 0) return Array.from(displayedLabels); // When unzoomed & zooming\n\n  if (zooming && cameraState.ratio >= 1) return Array.from(displayedLabels); // Adapting cell dimensions\n\n  var cell = userCell ? userCell : DEFAULT_CELL;\n  if (cameraState.ratio >= 1.3) cell = DEFAULT_UNZOOMED_CELL;\n  var cwr = dimensions.width % cell.width;\n  var cellWidth = cell.width + cwr / Math.floor(dimensions.width / cell.width);\n  var chr = dimensions.height % cell.height;\n  var cellHeight = cell.height + chr / Math.floor(dimensions.height / cell.height);\n  var adjustedWidth = dimensions.width + cellWidth,\n      adjustedHeight = dimensions.height + cellHeight,\n      adjustedX = -cellWidth,\n      adjustedY = -cellHeight;\n  var panningWidth = dimensions.width + cellWidth / 2,\n      panningHeight = dimensions.height + cellHeight / 2,\n      panningX = -(cellWidth / 2),\n      panningY = -(cellHeight / 2); // console.log(cellWidth, cellHeight, dimensions.width / cellWidth, dimensions.height / cellHeight);\n\n  var worthyLabels = [];\n  var grid = {};\n  var maxSize = -Infinity,\n      biggestNode = null;\n\n  for (var i = 0, l = visibleNodes.length; i < l; i++) {\n    var node = visibleNodes[i],\n        nodeData = cache[node]; // We filter nodes having a rendered size less than a certain thresold\n\n    if (nodeData.size / sizeRatio < renderedSizeThreshold) continue; // Finding our node's cell in the grid\n\n    var pos = camera.graphToViewport(dimensions, nodeData.x, nodeData.y); // Node is not actually visible on screen\n    // NOTE: can optimize margin on the right side (only if we know where the labels go)\n\n    if (pos.x < adjustedX || pos.x > adjustedWidth || pos.y < adjustedY || pos.y > adjustedHeight) continue; // Keeping track of the maximum node size for certain cases\n\n    if (nodeData.size > maxSize) {\n      maxSize = nodeData.size;\n      biggestNode = node;\n    } // If panning when zoomed, we consider only displayed labels and newly\n    // visible nodes\n\n\n    if (zoomedPanning) {\n      var ppos = previousCamera.graphToViewport(dimensions, nodeData.x, nodeData.y); // Was node visible earlier?\n\n      if (ppos.x >= panningX && ppos.x <= panningWidth && ppos.y >= panningY && ppos.y <= panningHeight) {\n        // Was the label displayed?\n        if (!displayedLabels.has(node)) continue;\n      }\n    }\n\n    var xKey = Math.floor(pos.x / cellWidth),\n        yKey = Math.floor(pos.y / cellHeight);\n    var key = \"\".concat(xKey, \"\\xA7\").concat(yKey);\n\n    if (typeof grid[key] === 'undefined') {\n      // This cell is not yet occupied\n      grid[key] = node;\n    } else {\n      // We must solve a conflict in this cell\n      var currentNode = grid[key],\n          currentNodeData = cache[currentNode]; // We prefer already displayed labels\n\n      if (displayedLabels.size > 0) {\n        var n1 = displayedLabels.has(node),\n            n2 = displayedLabels.has(currentNode);\n\n        if (!n1 && n2) {\n          continue;\n        }\n\n        if (n1 && !n2) {\n          grid[key] = node;\n          continue;\n        }\n\n        if ((zoomedPanning || zooming) && n1 && n2) {\n          worthyLabels.push(node);\n          continue;\n        }\n      } // In case of size & degree equality, we use the node's key so that the\n      // process remains deterministic\n\n\n      var won = false;\n\n      if (nodeData.size > currentNodeData.size) {\n        won = true;\n      } else if (nodeData.size === currentNodeData.size) {\n        var nodeDegree = graph.degree(node),\n            currentNodeDegree = graph.degree(currentNode);\n\n        if (nodeDegree > currentNodeDegree) {\n          won = true;\n        } else if (nodeDegree === currentNodeDegree) {\n          if (node > currentNode) won = true;\n        }\n      }\n\n      if (won) grid[key] = node;\n    }\n  } // Compiling the labels\n\n\n  var biggestNodeShown = worthyLabels.some(function (node) {\n    return node === biggestNode;\n  });\n\n  for (var _key in grid) {\n    var _node = grid[_key];\n    if (_node === biggestNode) biggestNodeShown = true;\n    worthyLabels.push(_node);\n  } // Always keeping biggest node shown on screen\n\n\n  if (!biggestNodeShown && biggestNode) worthyLabels.push(biggestNode); // Basic anti-collision\n\n  var collisions = new Set();\n\n  for (var _i = 0, _l = worthyLabels.length; _i < _l; _i++) {\n    var _n = worthyLabels[_i],\n        d1 = cache[_n],\n        p1 = camera.graphToViewport(dimensions, d1.x, d1.y);\n    if (collisions.has(_n)) continue;\n\n    for (var j = _i + 1; j < _l; j++) {\n      var _n2 = worthyLabels[j],\n          d2 = cache[_n2],\n          p2 = camera.graphToViewport(dimensions, d2.x, d2.y);\n      var c = collision( // First abstract bbox\n      p1.x, p1.y, d1.label.length * 8, fontSize, // Second abstract bbox\n      p2.x, p2.y, d2.label.length * 8, fontSize);\n\n      if (c) {\n        // NOTE: add degree as tie-breaker here if required in the future\n        // NOTE: add final stable tie-breaker using node key if required\n        if (d1.size < d2.size) collisions.add(_n);else collisions.add(_n2);\n      }\n    }\n  } // console.log(collisions)\n\n\n  return worthyLabels.filter(function (l) {\n    return !collisions.has(l);\n  });\n}\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\n\n\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n      hoveredNode = params.hoveredNode,\n      highlightedNodes = params.highlightedNodes,\n      displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = new Set();\n  var displayedNodeLabelsArray = Array.from(displayedNodeLabels); // Each edge connecting a highlighted node has its label displayed:\n\n  var highlightedNodesArray = Array.from(highlightedNodes);\n  if (hoveredNode && !highlightedNodes.has(hoveredNode)) highlightedNodesArray.push(hoveredNode);\n\n  for (var i = 0; i < highlightedNodesArray.length; i++) {\n    var key = highlightedNodesArray[i];\n    var edges = graph.edges(key);\n\n    for (var j = 0; j < edges.length; j++) {\n      worthyEdges.add(edges[j]);\n    }\n  } // Each edge connecting two nodes with visible labels has its label displayed:\n\n\n  for (var _i2 = 0; _i2 < displayedNodeLabelsArray.length; _i2++) {\n    var _key2 = displayedNodeLabelsArray[_i2];\n\n    var _edges = graph.outboundEdges(_key2);\n\n    for (var _j = 0; _j < _edges.length; _j++) {\n      if (displayedNodeLabels.has(graph.opposite(_key2, _edges[_j]))) worthyEdges.add(_edges[_j]);\n    }\n  }\n\n  return Array.from(worthyEdges);\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/heuristics/labels.js?");

/***/ }),

/***/ "./node_modules/sigma/heuristics/z-index.js":
/*!**************************************************!*\
  !*** ./node_modules/sigma/heuristics/z-index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zIndexOrdering = zIndexOrdering;\n\n/**\n * Sigma.js zIndex Heuristics\n * ===========================\n *\n * Miscelleneous heuristics related to z-index ordering of nodes & edges.\n */\n\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n *\n * @param  {number}   extent   - [min, max] z values.\n * @param  {function} getter   - Z attribute getter function.\n * @param  {array}    elements - The array to sort.\n * @return {array} - The sorted array.\n */\nfunction zIndexOrdering(extent, getter, elements) {\n  // const n = elements.length;\n  // const [min, max] = extent;\n  // const k = max - min;\n  // No ordering needs to be done\n  // if (k === 0 || k === -Infinity)\n  //   return elements;\n  // If k is > n, we'll use a standard sort\n  return elements.sort(function (a, b) {\n    var zA = getter(a) || 0,\n        zB = getter(b) || 0;\n    if (zA < zB) return -1;\n    if (zA > zB) return 1;\n    return 0;\n  }); // TODO: counting sort optimization\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/heuristics/z-index.js?");

/***/ }),

/***/ "./node_modules/sigma/quadtree.js":
/*!****************************************!*\
  !*** ./node_modules/sigma/quadtree.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _extend = _interopRequireDefault(__webpack_require__(/*! @yomguithereal/helpers/extend */ \"./node_modules/@yomguithereal/helpers/extend.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// TODO: should not ask the quadtree when the camera has the whole graph in\n// sight.\n// TODO: a square can be represented as topleft + width, saying for the quad blocks (reduce mem)\n// TODO: jsdoc\n// TODO: be sure we can handle cases overcoming boundaries (because of size) or use a maxed size\n// TODO: filtering unwanted labels beforehand through the filter function\n// NOTE: this is basically a MX-CIF Quadtree at this point\n// NOTE: need to explore R-Trees for edges\n// NOTE: need to explore 2d segment tree for edges\n// NOTE: probably can do faster using spatial hashing\n\n/**\n * Constants.\n *\n * Note that since we are representing a static 4-ary tree, the indices of the\n * quadrants are the following:\n *   - TOP_LEFT:     4i + b\n *   - TOP_RIGHT:    4i + 2b\n *   - BOTTOM_LEFT:  4i + 3b\n *   - BOTTOM_RIGHT: 4i + 4b\n */\nvar BLOCKS = 4,\n    MAX_LEVEL = 5;\nvar X_OFFSET = 0,\n    Y_OFFSET = 1,\n    WIDTH_OFFSET = 2,\n    HEIGHT_OFFSET = 3;\nvar TOP_LEFT = 1,\n    TOP_RIGHT = 2,\n    BOTTOM_LEFT = 3,\n    BOTTOM_RIGHT = 4;\n/**\n * Geometry helpers.\n */\n\n/**\n * Function returning whether the given rectangle is axis-aligned.\n *\n * @param  {number} x1\n * @param  {number} y1\n * @param  {number} x2\n * @param  {number} y2\n * @return {boolean}\n */\n\nfunction isAxisAligned(x1, y1, x2, y2) {\n  return x1 === x2 || y1 === y2;\n}\n\nfunction squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;\n}\n\nfunction rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;\n}\n\nfunction pointIsInQuad(x, y, qx, qy, qw, qh) {\n  var xmp = qx + qw / 2,\n      ymp = qy + qh / 2,\n      top = y < ymp,\n      left = x < xmp;\n  return top ? left ? TOP_LEFT : TOP_RIGHT : left ? BOTTOM_LEFT : BOTTOM_RIGHT;\n}\n/**\n * Helper functions that are not bound to the class so an external user\n * cannot mess with them.\n */\n\n\nfunction buildQuadrants(maxLevel, data) {\n  // [block, level]\n  var stack = [0, 0];\n\n  while (stack.length) {\n    var level = stack.pop(),\n        block = stack.pop();\n    var topLeftBlock = 4 * block + BLOCKS,\n        topRightBlock = 4 * block + 2 * BLOCKS,\n        bottomLeftBlock = 4 * block + 3 * BLOCKS,\n        bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var x = data[block + X_OFFSET],\n        y = data[block + Y_OFFSET],\n        width = data[block + WIDTH_OFFSET],\n        height = data[block + HEIGHT_OFFSET],\n        hw = width / 2,\n        hh = height / 2;\n    data[topLeftBlock + X_OFFSET] = x;\n    data[topLeftBlock + Y_OFFSET] = y;\n    data[topLeftBlock + WIDTH_OFFSET] = hw;\n    data[topLeftBlock + HEIGHT_OFFSET] = hh;\n    data[topRightBlock + X_OFFSET] = x + hw;\n    data[topRightBlock + Y_OFFSET] = y;\n    data[topRightBlock + WIDTH_OFFSET] = hw;\n    data[topRightBlock + HEIGHT_OFFSET] = hh;\n    data[bottomLeftBlock + X_OFFSET] = x;\n    data[bottomLeftBlock + Y_OFFSET] = y + hh;\n    data[bottomLeftBlock + WIDTH_OFFSET] = hw;\n    data[bottomLeftBlock + HEIGHT_OFFSET] = hh;\n    data[bottomRightBlock + X_OFFSET] = x + hw;\n    data[bottomRightBlock + Y_OFFSET] = y + hh;\n    data[bottomRightBlock + WIDTH_OFFSET] = hw;\n    data[bottomRightBlock + HEIGHT_OFFSET] = hh;\n\n    if (level < maxLevel - 1) {\n      stack.push(bottomRightBlock, level + 1);\n      stack.push(bottomLeftBlock, level + 1);\n      stack.push(topRightBlock, level + 1);\n      stack.push(topLeftBlock, level + 1);\n    }\n  }\n}\n\nfunction insertNode(maxLevel, data, containers, key, x, y, size) {\n  var x1 = x - size,\n      y1 = y - size,\n      w = size * 2;\n  var level = 0,\n      block = 0;\n\n  while (true) {\n    // If we reached max level\n    if (level >= maxLevel) {\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    }\n\n    var topLeftBlock = 4 * block + BLOCKS,\n        topRightBlock = 4 * block + 2 * BLOCKS,\n        bottomLeftBlock = 4 * block + 3 * BLOCKS,\n        bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    var collisions = collidingWithTopLeft + collidingWithTopRight + collidingWithBottomLeft + collidingWithBottomRight; // If we don't have at least a collision, there is an issue\n\n    if (collisions === 0) throw new Error(\"sigma/quadtree.insertNode: no collision (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\")); // If we have 3 collisions, we have a geometry problem obviously\n\n    if (collisions === 3) throw new Error(\"sigma/quadtree.insertNode: 3 impossible collisions (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\")); // If we have more that one collision, we stop here and store the node\n    // in the relevant containers\n\n    if (collisions > 1) {\n      // NOTE: this is a nice way to optimize for hover, but not for frustum\n      // since it requires to uniq the collected nodes\n      // if (collisions < 4) {\n      //   // If we intersect two quads, we place the node in those two\n      //   if (collidingWithTopLeft) {\n      //     containers[topLeftBlock] = containers[topLeftBlock] || [];\n      //     containers[topLeftBlock].push(key);\n      //   }\n      //   if (collidingWithTopRight) {\n      //     containers[topRightBlock] = containers[topRightBlock] || [];\n      //     containers[topRightBlock].push(key);\n      //   }\n      //   if (collidingWithBottomLeft) {\n      //     containers[bottomLeftBlock] = containers[bottomLeftBlock] || [];\n      //     containers[bottomLeftBlock].push(key);\n      //   }\n      //   if (collidingWithBottomRight) {\n      //     containers[bottomRightBlock] = containers[bottomRightBlock] || [];\n      //     containers[bottomRightBlock].push(key);\n      //   }\n      // }\n      // else {\n      //   // Else we keep the node where it is to avoid more pointless computations\n      //   containers[block] = containers[block] || [];\n      //   containers[block].push(key);\n      // }\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    } else {\n      level++;\n    } // Else we recurse into the correct quads\n\n\n    if (collidingWithTopLeft) block = topLeftBlock;\n    if (collidingWithTopRight) block = topRightBlock;\n    if (collidingWithBottomLeft) block = bottomLeftBlock;\n    if (collidingWithBottomRight) block = bottomRightBlock;\n  }\n}\n\nfunction getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {\n  // [block, level]\n  var stack = [0, 0];\n  var collectedNodes = [];\n  var container;\n\n  while (stack.length) {\n    var level = stack.pop(),\n        block = stack.pop(); // Collecting nodes\n\n    container = containers[block];\n    if (container) (0, _extend[\"default\"])(collectedNodes, container); // If we reached max level\n\n    if (level >= maxLevel) continue;\n    var topLeftBlock = 4 * block + BLOCKS,\n        topRightBlock = 4 * block + 2 * BLOCKS,\n        bottomLeftBlock = 4 * block + 3 * BLOCKS,\n        bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    if (collidingWithTopLeft) stack.push(topLeftBlock, level + 1);\n    if (collidingWithTopRight) stack.push(topRightBlock, level + 1);\n    if (collidingWithBottomLeft) stack.push(bottomLeftBlock, level + 1);\n    if (collidingWithBottomRight) stack.push(bottomRightBlock, level + 1);\n  }\n\n  return collectedNodes;\n}\n/**\n * QuadTree class.\n *\n * @constructor\n * @param {object} boundaries - The graph boundaries.\n */\n\n\nvar QuadTree =\n/*#__PURE__*/\nfunction () {\n  function QuadTree(params) {\n    _classCallCheck(this, QuadTree);\n\n    params = params || {}; // Allocating the underlying byte array\n\n    var L = Math.pow(4, MAX_LEVEL);\n    this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));\n    this.containers = {};\n    this.cache = null;\n    this.lastRectangle = null;\n    if (params.boundaries) this.resize(params.boundaries);else this.resize({\n      x: 0,\n      y: 0,\n      width: 1,\n      height: 1\n    });\n    if (typeof params.filter === 'function') this.nodeFilter = params.filter;\n  }\n\n  _createClass(QuadTree, [{\n    key: \"add\",\n    value: function add(key, x, y, size) {\n      insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(boundaries) {\n      this.clear(); // Building the quadrants\n\n      this.data[X_OFFSET] = boundaries.x;\n      this.data[Y_OFFSET] = boundaries.y;\n      this.data[WIDTH_OFFSET] = boundaries.width;\n      this.data[HEIGHT_OFFSET] = boundaries.height;\n      buildQuadrants(MAX_LEVEL, this.data);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.containers = {};\n      return this;\n    }\n  }, {\n    key: \"point\",\n    value: function point(x, y) {\n      var nodes = [];\n      var block = 0,\n          level = 0;\n\n      do {\n        if (this.containers[block]) nodes.push.apply(nodes, this.containers[block]);\n        var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);\n        block = 4 * block + quad * BLOCKS;\n        level++;\n      } while (level <= MAX_LEVEL);\n\n      return nodes;\n    }\n  }, {\n    key: \"rectangle\",\n    value: function rectangle(x1, y1, x2, y2, height) {\n      var lr = this.lastRectangle;\n\n      if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {\n        return this.cache;\n      }\n\n      this.lastRectangle = {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        height: height\n      }; // Is the rectangle axis aligned?\n\n      if (!isAxisAligned(x1, y1, x2, y2)) throw new Error('sigma/quadtree.rectangle: shifted view is not yet implemented.');\n      var collectedNodes = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height);\n      this.cache = collectedNodes;\n      return this.cache;\n    }\n  }]);\n\n  return QuadTree;\n}();\n\nexports[\"default\"] = QuadTree;\n\n//# sourceURL=webpack:///./node_modules/sigma/quadtree.js?");

/***/ }),

/***/ "./node_modules/sigma/renderer.js":
/*!****************************************!*\
  !*** ./node_modules/sigma/renderer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Renderer class.\n *\n * @constructor\n */\nvar Renderer =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Renderer, _EventEmitter);\n\n  function Renderer() {\n    _classCallCheck(this, Renderer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Renderer).apply(this, arguments));\n  }\n\n  return Renderer;\n}(_events.EventEmitter);\n\nexports[\"default\"] = Renderer;\n\n//# sourceURL=webpack:///./node_modules/sigma/renderer.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/canvas/components/edge-label.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sigma/renderers/canvas/components/edge-label.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = drawEdgeLabel;\n\n/**\n * Sigma.js Canvas Renderer Edge Label Component\n * =============================================\n *\n * Function used by the canvas renderer to display a single edge's label.\n */\nfunction drawEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n  var size = settings.edgeLabelSize,\n      font = settings.edgeLabelFont,\n      weight = settings.edgeLabelWeight,\n      label = edgeData.label;\n  context.fillStyle = edgeData.color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  var textWidth = context.measureText(label).width;\n  var cx = (sourceData.x + targetData.x) / 2;\n  var cy = (sourceData.y + targetData.y) / 2;\n  var dx = targetData.x - sourceData.x;\n  var dy = targetData.y - sourceData.y;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  var angle;\n\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.fillText(label, -textWidth / 2, edgeData.size / 2 + size);\n  context.restore();\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/canvas/components/edge-label.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/canvas/components/hover.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sigma/renderers/canvas/components/hover.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = drawHover;\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./node */ \"./node_modules/sigma/renderers/canvas/components/node.js\"));\n\nvar _label = _interopRequireDefault(__webpack_require__(/*! ./label */ \"./node_modules/sigma/renderers/canvas/components/label.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Sigma.js Canvas Renderer Hover Component\n * =========================================\n *\n * Function used by the canvas renderer to display a single node's hovered\n * state.\n */\nfunction drawHover(context, data, settings) {\n  var size = settings.labelSize,\n      font = settings.labelFont,\n      weight = settings.labelWeight;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font); // Then we draw the label background\n\n  context.beginPath();\n  context.fillStyle = '#fff';\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = '#000';\n  var textWidth = context.measureText(data.label).width;\n  var x = Math.round(data.x - size / 2 - 2),\n      y = Math.round(data.y - size / 2 - 2),\n      w = Math.round(textWidth + size / 2 + data.size + 9),\n      h = Math.round(size + 4),\n      e = Math.round(size / 2 + 2);\n  context.moveTo(x, y + e);\n  context.moveTo(x, y + e);\n  context.arcTo(x, y, x + e, y, e);\n  context.lineTo(x + w, y);\n  context.lineTo(x + w, y + h);\n  context.lineTo(x + e, y + h);\n  context.arcTo(x, y + h, x, y + h - e, e);\n  context.lineTo(x, y + e);\n  context.closePath();\n  context.fill();\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0; // Then we need to draw the node\n\n  (0, _node[\"default\"])(context, data); // And finally we draw the label\n\n  (0, _label[\"default\"])(context, data, settings);\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/canvas/components/hover.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/canvas/components/label.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sigma/renderers/canvas/components/label.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = drawLabel;\n\n/**\n * Sigma.js Canvas Renderer Label Component\n * =========================================\n *\n * Function used by the canvas renderer to display a single node's label.\n */\nfunction drawLabel(context, data, settings) {\n  var size = settings.labelSize,\n      font = settings.labelFont,\n      weight = settings.labelWeight;\n  context.fillStyle = '#000';\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/canvas/components/label.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/canvas/components/node.js":
/*!****************************************************************!*\
  !*** ./node_modules/sigma/renderers/canvas/components/node.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = drawNode;\n\n/**\n * Sigma.js Canvas Renderer Node Component\n * ========================================\n *\n * Function used by the canvas renderer to display a single node.\n */\nvar PI_TIMES_2 = Math.PI * 2;\n\nfunction drawNode(context, data) {\n  context.fillStyle = data.color;\n  context.beginPath();\n  context.arc(data.x, data.y, data.size, 0, PI_TIMES_2, true);\n  context.closePath();\n  context.fill();\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/canvas/components/node.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/display-data.js":
/*!******************************************************!*\
  !*** ./node_modules/sigma/renderers/display-data.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EdgeDisplayData = exports.NodeDisplayData = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Sigma.js Display Data Classes\n * ==============================\n *\n * Classes representing nodes & edges display data aiming at facilitating\n * the engine's memory representation and keep them in a pool to avoid\n * requiring to allocate memory too often.\n *\n * NOTE: it's possible to optimize this further by maintaining display data\n * in byte arrays but this would prove more tedious for the rendering logic\n * afterwards.\n */\nvar NodeDisplayData =\n/*#__PURE__*/\nfunction () {\n  function NodeDisplayData(index, settings) {\n    _classCallCheck(this, NodeDisplayData);\n\n    this.index = index;\n    this.x = 0;\n    this.y = 0;\n    this.size = 2;\n    this.color = settings.defaultNodeColor;\n    this.hidden = false;\n    this.label = '';\n  }\n\n  _createClass(NodeDisplayData, [{\n    key: \"assign\",\n    value: function assign(data) {\n      for (var key in data) {\n        this[key] = data[key];\n      }\n    }\n  }]);\n\n  return NodeDisplayData;\n}();\n\nexports.NodeDisplayData = NodeDisplayData;\n\nvar EdgeDisplayData =\n/*#__PURE__*/\nfunction () {\n  function EdgeDisplayData(index, settings) {\n    _classCallCheck(this, EdgeDisplayData);\n\n    this.index = index;\n    this.size = 1;\n    this.color = settings.defaultEdgeColor;\n    this.hidden = false;\n    this.label = '';\n  }\n\n  _createClass(EdgeDisplayData, [{\n    key: \"assign\",\n    value: function assign(data) {\n      for (var key in data) {\n        this[key] = data[key];\n      }\n    }\n  }]);\n\n  return EdgeDisplayData;\n}();\n\nexports.EdgeDisplayData = EdgeDisplayData;\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/display-data.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/sigma/renderers/utils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createElement = createElement;\nexports.getPixelRatio = getPixelRatio;\nexports.createNormalizationFunction = createNormalizationFunction;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * Sigma.js Rendering Utils\n * ===========================\n *\n * Helpers used by most renderers.\n */\n\n/**\n * Function used to create DOM elements easily.\n *\n * @param  {string} tag        - Tag name of the element to create.\n * @param  {object} attributes - Attributes map.\n * @return {HTMLElement}\n */\nfunction createElement(tag, attributes) {\n  var element = document.createElement(tag);\n  if (!attributes) return element;\n\n  for (var k in attributes) {\n    if (k === 'style') {\n      for (var s in attributes[k]) {\n        element.style[s] = attributes[k][s];\n      }\n    } else {\n      element.setAttribute(k, attributes[k]);\n    }\n  }\n\n  return element;\n}\n/**\n * Function returning the browser's pixel ratio.\n *\n * @return {number}\n */\n\n\nfunction getPixelRatio() {\n  var screen = window.screen;\n  if (typeof screen.deviceXDPI !== 'undefined' && typeof screen.logicalXDPI !== 'undefined' && screen.deviceXDPI > screen.logicalXDPI) return screen.systemXDPI / screen.logicalXDPI;else if (typeof window.devicePixelRatio !== 'undefined') return window.devicePixelRatio;\n  return 1;\n}\n/**\n * Factory returning a function normalizing the given node's position & size.\n *\n * @param  {object}   extent  - Extent of the graph.\n * @return {function}\n */\n\n\nfunction createNormalizationFunction(extent) {\n  var _extent$x = _slicedToArray(extent.x, 2),\n      minX = _extent$x[0],\n      maxX = _extent$x[1],\n      _extent$y = _slicedToArray(extent.y, 2),\n      minY = _extent$y[0],\n      maxY = _extent$y[1];\n\n  var ratio = Math.max(maxX - minX, maxY - minY);\n  if (ratio === 0) ratio = 1;\n  var dX = (maxX + minX) / 2,\n      dY = (maxY + minY) / 2;\n\n  var fn = function fn(data) {\n    return {\n      x: 0.5 + (data.x - dX) / ratio,\n      y: 0.5 + (data.y - dY) / ratio\n    };\n  }; // TODO: possibility to apply this in batch over array of indices\n\n\n  fn.applyTo = function (data) {\n    data.x = 0.5 + (data.x - dX) / ratio;\n    data.y = 0.5 + (data.y - dY) / ratio;\n  };\n\n  fn.inverse = function (data) {\n    return {\n      x: dX + ratio * (data.x - 0.5),\n      y: dY + ratio * (data.y - 0.5)\n    };\n  };\n\n  fn.ratio = ratio;\n  return fn;\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/utils.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _extent = __webpack_require__(/*! graphology-metrics/extent */ \"./node_modules/graphology-metrics/extent.js\");\n\nvar _isGraph = _interopRequireDefault(__webpack_require__(/*! graphology-utils/is-graph */ \"./node_modules/graphology-utils/is-graph.js\"));\n\nvar _renderer = _interopRequireDefault(__webpack_require__(/*! ../../renderer */ \"./node_modules/sigma/renderer.js\"));\n\nvar _camera = _interopRequireDefault(__webpack_require__(/*! ../../camera */ \"./node_modules/sigma/camera.js\"));\n\nvar _mouse = _interopRequireDefault(__webpack_require__(/*! ../../captors/mouse */ \"./node_modules/sigma/captors/mouse.js\"));\n\nvar _quadtree = _interopRequireDefault(__webpack_require__(/*! ../../quadtree */ \"./node_modules/sigma/quadtree.js\"));\n\nvar _displayData2 = __webpack_require__(/*! ../display-data */ \"./node_modules/sigma/renderers/display-data.js\");\n\nvar _utils = __webpack_require__(/*! ../../utils */ \"./node_modules/sigma/utils.js\");\n\nvar _utils2 = __webpack_require__(/*! ../utils */ \"./node_modules/sigma/renderers/utils.js\");\n\nvar _utils3 = __webpack_require__(/*! ./utils */ \"./node_modules/sigma/renderers/webgl/utils.js\");\n\nvar _labels = __webpack_require__(/*! ../../heuristics/labels */ \"./node_modules/sigma/heuristics/labels.js\");\n\nvar _zIndex = __webpack_require__(/*! ../../heuristics/z-index */ \"./node_modules/sigma/heuristics/z-index.js\");\n\nvar _settings = __webpack_require__(/*! ./settings */ \"./node_modules/sigma/renderers/webgl/settings.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Constants.\n */\nvar PIXEL_RATIO = (0, _utils2.getPixelRatio)();\nvar WEBGL_OVERSAMPLING_RATIO = (0, _utils2.getPixelRatio)();\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\n\nvar WebGLRenderer =\n/*#__PURE__*/\nfunction (_Renderer) {\n  _inherits(WebGLRenderer, _Renderer);\n\n  function WebGLRenderer(graph, container, settings) {\n    var _this;\n\n    _classCallCheck(this, WebGLRenderer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLRenderer).call(this));\n    settings = settings || {};\n    _this.settings = (0, _utils.assign)({}, _settings.WEBGL_RENDERER_DEFAULT_SETTINGS, settings);\n    (0, _settings.validateWebglRendererSettings)(_this.settings); // Validating\n\n    if (!(0, _isGraph[\"default\"])(graph)) throw new Error('sigma/renderers/webgl: invalid graph instance.');\n    if (!(container instanceof HTMLElement)) throw new Error('sigma/renderers/webgl: container should be an html element.'); // Properties\n\n    _this.graph = graph;\n    _this.captors = {};\n    _this.container = container;\n    _this.elements = {};\n    _this.contexts = {};\n    _this.listeners = {}; // Indices & cache\n    // TODO: this could be improved by key => index => floatArray\n    // TODO: the cache should erase keys on node delete & add new\n\n    _this.quadtree = new _quadtree[\"default\"]();\n    _this.nodeDataCache = {};\n    _this.edgeDataCache = {};\n    _this.nodeExtent = null;\n    _this.edgeExtent = null;\n\n    _this.initializeCache(); // Normalization function\n\n\n    _this.normalizationFunction = null; // Starting dimensions\n\n    _this.width = 0;\n    _this.height = 0; // State\n\n    _this.highlightedNodes = new Set();\n    _this.displayedLabels = new Set();\n    _this.hoveredNode = null;\n    _this.wasRenderedInThisFrame = false;\n    _this.renderFrame = null;\n    _this.renderHighlightedNodesFrame = null;\n    _this.needToProcess = false;\n    _this.needToSoftProcess = false; // Initializing contexts\n\n    _this.createContext('edges');\n\n    _this.createContext('edgeLabels', false);\n\n    _this.createContext('nodes');\n\n    _this.createContext('labels', false);\n\n    _this.createContext('hovers', false);\n\n    _this.createContext('mouse', false); // Blending\n\n\n    var gl = _this.contexts.nodes;\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.enable(gl.BLEND);\n    gl = _this.contexts.edges;\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.enable(gl.BLEND); // Loading programs\n\n    _this.nodePrograms = {};\n    _this.edgePrograms = {};\n\n    for (var type in _this.settings.nodeProgramClasses) {\n      var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n      _this.nodePrograms[type] = new NodeProgramClass(_this.contexts.nodes);\n    }\n\n    for (var _type in _this.settings.edgeProgramClasses) {\n      var EdgeProgramClass = _this.settings.edgeProgramClasses[_type];\n      _this.edgePrograms[_type] = new EdgeProgramClass(_this.contexts.edges);\n    } // Initial resize\n\n\n    _this.resize(); // Initializing the camera\n\n\n    _this.camera = new _camera[\"default\"]({\n      width: _this.width,\n      height: _this.height\n    }); // Binding camera events\n\n    _this.bindCameraHandlers(); // Initializing captors\n\n\n    _this.captors = {\n      mouse: new _mouse[\"default\"](_this.elements.mouse, _this.camera)\n    }; // Binding event handlers\n\n    _this.bindEventHandlers(); // Binding graph handlers\n\n\n    _this.bindGraphHandlers(); // Processing data for the first time & render\n\n\n    _this.process();\n\n    _this.render();\n\n    return _this;\n  }\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string}  id    - Context's id.\n   * @param  {boolean} webgl - Whether the context is a webgl or canvas one.\n   * @return {WebGLRenderer}\n   */\n\n\n  _createClass(WebGLRenderer, [{\n    key: \"createContext\",\n    value: function createContext(id) {\n      var webgl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var element = (0, _utils2.createElement)('canvas', {\n        \"class\": \"sigma-\".concat(id),\n        style: {\n          position: 'absolute'\n        }\n      });\n      this.elements[id] = element;\n      this.container.appendChild(element);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      var context;\n\n      if (webgl) {\n        // First we try webgl2 for an easy performance boost\n        context = element.getContext('webgl2', contextOptions); // Else we fall back to webgl\n\n        if (!context) context = element.getContext('webgl', contextOptions); // Edge, I am looking right at you...\n\n        if (!context) context = element.getContext('experimental-webgl', contextOptions);\n      } else {\n        context = element.getContext('2d', contextOptions);\n      }\n\n      this.contexts[id] = context;\n      return this;\n    }\n    /**\n     * Method used to initialize display data cache.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"initializeCache\",\n    value: function initializeCache() {\n      var graph = this.graph;\n      var nodes = graph.nodes();\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        this.nodeDataCache[nodes[i]] = new _displayData2.NodeDisplayData(i, this.settings);\n      }\n\n      var edges = graph.edges();\n\n      for (var _i = 0, _l = edges.length; _i < _l; _i++) {\n        this.edgeDataCache[edges[_i]] = new _displayData2.EdgeDisplayData(_i, this.settings);\n      }\n    }\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n\n      this.listeners.camera = function () {\n        _this2.scheduleRender();\n      };\n\n      this.camera.on('updated', this.listeners.camera);\n      return this;\n    }\n    /**\n     * Method binding event handlers.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n\n      // Handling window resize\n      this.listeners.handleResize = function () {\n        _this3.needToSoftProcess = true;\n\n        _this3.scheduleRender();\n      };\n\n      window.addEventListener('resize', this.listeners.handleResize); // Function checking if the mouse is on the given node\n\n      var mouseIsOnNode = function mouseIsOnNode(mouseX, mouseY, nodeX, nodeY, size) {\n        return mouseX > nodeX - size && mouseX < nodeX + size && mouseY > nodeY - size && mouseY < nodeY + size && Math.sqrt(Math.pow(mouseX - nodeX, 2) + Math.pow(mouseY - nodeY, 2)) < size;\n      }; // Function returning the nodes in the mouse's quad\n\n\n      var getQuadNodes = function getQuadNodes(mouseX, mouseY) {\n        var mouseGraphPosition = _this3.camera.viewportToGraph(_this3, mouseX, mouseY); // TODO: minus 1? lol\n\n\n        return _this3.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n      }; // Handling mouse move\n\n\n      this.listeners.handleMove = function (e) {\n        // NOTE: for the canvas renderer, testing the pixel's alpha should\n        // give some boost but this slows things down for WebGL empirically.\n        // TODO: this should be a method from the camera (or can be passed to graph to display somehow)\n        var sizeRatio = Math.pow(_this3.camera.getState().ratio, 0.5);\n        var quadNodes = getQuadNodes(e.x, e.y); // We will hover the node whose center is closest to mouse\n\n        var minDistance = Infinity,\n            nodeToHover = null;\n\n        for (var i = 0, l = quadNodes.length; i < l; i++) {\n          var node = quadNodes[i];\n          var data = _this3.nodeDataCache[node];\n\n          var pos = _this3.camera.graphToViewport(_this3, data.x, data.y);\n\n          var size = data.size / sizeRatio;\n\n          if (mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) {\n            var distance = Math.sqrt(Math.pow(e.x - pos.x, 2) + Math.pow(e.y - pos.y, 2)); // TODO: sort by min size also for cases where center is the same\n\n            if (distance < minDistance) {\n              minDistance = distance;\n              nodeToHover = node;\n            }\n          }\n        }\n\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode !== null) _this3.emit('leaveNode', {\n            node: _this3.hoveredNode\n          });\n          _this3.hoveredNode = nodeToHover;\n\n          _this3.emit('enterNode', {\n            node: nodeToHover\n          });\n\n          return _this3.scheduleHighlightedNodesRender();\n        } // Checking if the hovered node is still hovered\n\n\n        if (_this3.hoveredNode) {\n          var _data = _this3.nodeDataCache[_this3.hoveredNode];\n\n          var _pos = _this3.camera.graphToViewport(_this3, _data.x, _data.y);\n\n          var _size = _data.size / sizeRatio;\n\n          if (!mouseIsOnNode(e.x, e.y, _pos.x, _pos.y, _size)) {\n            var _node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n\n            _this3.emit('leaveNode', {\n              node: _node\n            });\n\n            return _this3.scheduleHighlightedNodesRender();\n          }\n        }\n      }; // Handling click\n\n\n      this.listeners.handleClick = function (e) {\n        var sizeRatio = Math.pow(_this3.camera.getState().ratio, 0.5);\n        var quadNodes = getQuadNodes(e.x, e.y);\n\n        for (var i = 0, l = quadNodes.length; i < l; i++) {\n          var node = quadNodes[i];\n          var data = _this3.nodeDataCache[node];\n\n          var pos = _this3.camera.graphToViewport(_this3, data.x, data.y);\n\n          var size = data.size / sizeRatio;\n          if (mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) return _this3.emit('clickNode', {\n            node: node,\n            captor: e\n          });\n        }\n\n        return _this3.emit('clickStage');\n      };\n\n      this.captors.mouse.on('mousemove', this.listeners.handleMove);\n      this.captors.mouse.on('click', this.listeners.handleClick);\n      return this;\n    }\n    /**\n     * Method binding graph handlers\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n\n      var graph = this.graph;\n\n      this.listeners.graphUpdate = function () {\n        _this4.needToProcess = true;\n\n        _this4.scheduleRender();\n      };\n\n      this.listeners.softGraphUpdate = function () {\n        _this4.needToSoftProcess = true;\n\n        _this4.scheduleRender();\n      };\n\n      this.listeners.addNodeGraphUpdate = function (e) {\n        // Adding entry to cache\n        _this4.nodeDataCache[e.key] = new _displayData2.NodeDisplayData(graph.order - 1, _this4.settings);\n\n        _this4.listeners.graphUpdate();\n      };\n\n      this.listeners.addEdgeGraphUpdate = function (e) {\n        // Adding entry to cache\n        _this4.edgeDataCache[e.key] = new _displayData2.EdgeDisplayData(graph.size - 1, _this4.settings);\n\n        _this4.listeners.graphUpdate();\n      }; // TODO: clean cache on drop!\n      // TODO: bind this on composed state events\n      // TODO: it could be possible to update only specific node etc. by holding\n      // a fixed-size pool of updated items\n\n\n      graph.on('nodeAdded', this.listeners.addNodeGraphUpdate);\n      graph.on('nodeDropped', this.listeners.graphUpdate);\n      graph.on('nodeAttributesUpdated', this.listeners.softGraphUpdate);\n      graph.on('edgeAdded', this.listeners.addEdgeGraphUpdate);\n      graph.on('nodeDropped', this.listeners.graphUpdate);\n      graph.on('edgeAttributesUpdated', this.listeners.softGraphUpdate);\n      graph.on('cleared', this.listeners.graphUpdate);\n      return this;\n    }\n    /**\n     * Method used to process the whole graph's data.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"process\",\n    value: function process() {\n      var keepArrays = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var graph = this.graph,\n          settings = this.settings; // Clearing the quad\n\n      this.quadtree.clear(); // Computing extents\n\n      var nodeExtentProperties = ['x', 'y'];\n\n      if (this.settings.zIndex) {\n        nodeExtentProperties.push('z');\n        this.edgeExtent = (0, _extent.edgeExtent)(graph, ['z']);\n      }\n\n      this.nodeExtent = (0, _extent.nodeExtent)(graph, nodeExtentProperties); // Rescaling function\n\n      this.normalizationFunction = (0, _utils2.createNormalizationFunction)(this.nodeExtent);\n      var nodeProgram = this.nodePrograms[this.settings.defaultNodeType];\n      if (!keepArrays) nodeProgram.allocate(graph.order);\n      var nodes = graph.nodes(); // Handling node z-index\n      // TODO: z-index needs us to compute display data before hand\n      // TODO: remains to be seen if reducers are a good or bad thing and if we\n      // should store display data in flat byte arrays indices\n\n      if (this.settings.zIndex) nodes = (0, _zIndex.zIndexOrdering)(this.edgeExtent.z, function (node) {\n        return graph.getNodeAttribute(node, 'z');\n      }, nodes);\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = graph.getNodeAttributes(node);\n        var displayData = this.nodeDataCache[node];\n        if (settings.nodeReducer) data = settings.nodeReducer(node, data); // TODO: should assign default also somewhere here if there is a reducer\n\n        displayData.assign(data);\n        this.normalizationFunction.applyTo(displayData);\n        this.quadtree.add(node, displayData.x, 1 - displayData.y, displayData.size / this.width);\n        nodeProgram.process(displayData, i);\n        displayData.index = i;\n      }\n\n      nodeProgram.bufferData();\n      var edgeProgram = this.edgePrograms[this.settings.defaultEdgeType];\n      if (!keepArrays) edgeProgram.allocate(graph.size);\n      var edges = graph.edges(); // Handling edge z-index\n\n      if (this.settings.zIndex) edges = (0, _zIndex.zIndexOrdering)(this.edgeExtent.z, function (edge) {\n        return graph.getEdgeAttribute(edge, 'z');\n      }, edges);\n\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n\n        var _data2 = graph.getEdgeAttributes(edge);\n\n        var _displayData = this.edgeDataCache[edge];\n        if (settings.edgeReducer) _data2 = settings.edgeReducer(edge, _data2);\n\n        _displayData.assign(_data2);\n\n        var extremities = graph.extremities(edge),\n            sourceData = this.nodeDataCache[extremities[0]],\n            targetData = this.nodeDataCache[extremities[1]];\n        edgeProgram.process(sourceData, targetData, _displayData, _i2);\n        _displayData.index = _i2;\n      } // Computing edge indices if necessary\n\n\n      if (!keepArrays && typeof edgeProgram.computeIndices === 'function') edgeProgram.computeIndices();\n      edgeProgram.bufferData();\n      return this;\n    }\n    /**\n     * Method used to process a single node.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"processNode\",\n    value: function processNode(key) {\n      var nodeProgram = this.nodePrograms[this.settings.defaultNodeType];\n      var data = this.graph.getNodeAttributes(key);\n      nodeProgram.process(data, this.nodeDataCache[key].index);\n      return this;\n    }\n    /**\n     * Method used to process a single edge.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"processEdge\",\n    value: function processEdge(key) {\n      var graph = this.graph;\n      var edgeProgram = this.edgePrograms[this.settings.defaultEdgeType];\n      var data = graph.getEdgeAttributes(key),\n          extremities = graph.extremities(key),\n          sourceData = graph.getNodeAttributes(extremities[0]),\n          targetData = graph.getNodeAttributes(extremities[1]);\n      edgeProgram.process(sourceData, targetData, data, this.edgeDataCache[key].index);\n      return this;\n    }\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {Camera}\n     */\n\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.captors.mouse;\n    }\n    /**\n     * Method used to resize the renderer.\n     *\n     * @param  {number} width  - Target width.\n     * @param  {number} height - Target height.\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      var previousWidth = this.width,\n          previousHeight = this.height;\n\n      if (arguments.length > 1) {\n        this.width = width;\n        this.height = height;\n      } else {\n        this.width = this.container.offsetWidth;\n        this.height = this.container.offsetHeight;\n      }\n\n      if (this.width === 0) throw new Error('sigma/renderers/webgl: container has no width.');\n      if (this.height === 0) throw new Error('sigma/renderers/webgl: container has no height.'); // If nothing has changed, we can stop right here\n\n      if (previousWidth === this.width && previousHeight === this.height) return this; // Sizing dom elements\n\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + 'px';\n        element.style.height = this.height + 'px';\n      } // Sizing contexts\n\n\n      for (var _id in this.contexts) {\n        var context = this.contexts[_id]; // Canvas contexts\n\n        if (context.scale) {\n          this.elements[_id].setAttribute('width', this.width * PIXEL_RATIO + 'px');\n\n          this.elements[_id].setAttribute('height', this.height * PIXEL_RATIO + 'px');\n\n          if (PIXEL_RATIO !== 1) context.scale(PIXEL_RATIO, PIXEL_RATIO);\n        } // WebGL contexts\n        else {\n            this.elements[_id].setAttribute('width', this.width * WEBGL_OVERSAMPLING_RATIO + 'px');\n\n            this.elements[_id].setAttribute('height', this.height * WEBGL_OVERSAMPLING_RATIO + 'px');\n          }\n\n        if (context.viewport) {\n          context.viewport(0, 0, this.width * WEBGL_OVERSAMPLING_RATIO, this.height * WEBGL_OVERSAMPLING_RATIO);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Method used to clear the canvases.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);\n      this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);\n      this.contexts.labels.clearRect(0, 0, this.width, this.height);\n      this.contexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.contexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      return this;\n    }\n    /**\n     * Method used to render.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n        this.needToProcess = false;\n        this.needToSoftProcess = false;\n      } // First we need to resize\n\n\n      this.resize(); // Clearing the canvases\n\n      this.clear(); // If we have no nodes we can stop right there\n\n      if (!this.graph.order) return this; // TODO: improve this heuristic or move to the captor itself?\n\n      var moving = this.camera.isAnimated() || this.captors.mouse.isMoving || this.captors.mouse.hasDragged || this.captors.mouse.wheelLock; // Then we need to extract a matrix from the camera\n\n      var cameraState = this.camera.getState(),\n          cameraMatrix = (0, _utils3.matrixFromCamera)(cameraState, {\n        width: this.width,\n        height: this.height\n      });\n      var program; // Drawing nodes\n\n      program = this.nodePrograms[this.settings.defaultNodeType];\n      program.render({\n        matrix: cameraMatrix,\n        width: this.width,\n        height: this.height,\n        ratio: cameraState.ratio,\n        nodesPowRatio: 0.5,\n        scalingRatio: WEBGL_OVERSAMPLING_RATIO\n      }); // Drawing edges\n\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        program = this.edgePrograms[this.settings.defaultEdgeType];\n        program.render({\n          matrix: cameraMatrix,\n          width: this.width,\n          height: this.height,\n          ratio: cameraState.ratio,\n          nodesPowRatio: 0.5,\n          edgesPowRatio: 0.5,\n          scalingRatio: WEBGL_OVERSAMPLING_RATIO\n        });\n      } // Do not display labels on move per setting\n\n\n      if (this.settings.hideLabelsOnMove && moving) return this;\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return this;\n    }\n    /**\n     * Method used to render labels.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState(); // Finding visible nodes to display their labels\n\n      var visibleNodes;\n\n      if (cameraState.ratio >= 1) {\n        // Camera is unzoomed so no need to ask the quadtree for visible nodes\n        visibleNodes = this.graph.nodes();\n      } else {\n        // Let's ask the quadtree\n        var viewRectangle = this.camera.viewRectangle(this);\n        visibleNodes = this.quadtree.rectangle(viewRectangle.x1, 1 - viewRectangle.y1, viewRectangle.x2, 1 - viewRectangle.y2, viewRectangle.height);\n      } // Selecting labels to draw\n\n\n      var gridSettings = this.settings.labelGrid;\n      var labelsToDisplay = (0, _labels.labelsToDisplayFromGrid)({\n        cache: this.nodeDataCache,\n        camera: this.camera,\n        cell: gridSettings.cell,\n        dimensions: this,\n        displayedLabels: this.displayedLabels,\n        fontSize: this.settings.labelSize,\n        graph: this.graph,\n        renderedSizeThreshold: gridSettings.renderedSizeThreshold,\n        visibleNodes: visibleNodes\n      }); // Drawing labels\n\n      var context = this.contexts.labels;\n      var sizeRatio = Math.pow(cameraState.ratio, 0.5);\n\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var data = this.nodeDataCache[labelsToDisplay[i]];\n\n        var _this$camera$graphToV = this.camera.graphToViewport(this, data.x, data.y),\n            x = _this$camera$graphToV.x,\n            y = _this$camera$graphToV.y; // TODO: we can cache the labels we need to render until the camera's ratio changes\n        // TODO: this should be computed in the canvas components?\n\n\n        var size = data.size / sizeRatio;\n        this.settings.labelRenderer(context, {\n          key: labelsToDisplay[i],\n          label: data.label,\n          size: size,\n          x: x,\n          y: y\n        }, this.settings);\n      } // Caching visible nodes and displayed labels\n\n\n      this.displayedLabels = new Set(labelsToDisplay);\n      return this;\n    }\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var cameraState = this.camera.getState();\n      var sizeRatio = Math.pow(cameraState.ratio, 0.5);\n      var context = this.contexts.edgeLabels; // Clearing\n\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = (0, _labels.edgeLabelsToDisplayFromNodes)({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n            extremities = this.graph.extremities(edge),\n            sourceData = this.nodeDataCache[extremities[0]],\n            targetData = this.nodeDataCache[extremities[1]],\n            edgeData = this.edgeDataCache[edgeLabelsToDisplay[i]];\n\n        var _this$camera$graphToV2 = this.camera.graphToViewport(this, sourceData.x, sourceData.y),\n            sourceX = _this$camera$graphToV2.x,\n            sourceY = _this$camera$graphToV2.y;\n\n        var _this$camera$graphToV3 = this.camera.graphToViewport(this, targetData.x, targetData.y),\n            targetX = _this$camera$graphToV3.x,\n            targetY = _this$camera$graphToV3.y; // TODO: we can cache the labels we need to render until the camera's ratio changes\n        // TODO: this should be computed in the canvas components?\n\n\n        var size = edgeData.size / sizeRatio;\n        this.settings.edgeLabelRenderer(context, {\n          key: edge,\n          label: edgeData.label,\n          color: edgeData.color,\n          size: size\n        }, {\n          key: extremities[0],\n          x: sourceX,\n          y: sourceY\n        }, {\n          key: extremities[1],\n          x: targetX,\n          y: targetY\n        }, this.settings);\n      }\n\n      return this;\n    }\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this5 = this;\n\n      var camera = this.camera;\n      var sizeRatio = Math.pow(camera.getState().ratio, 0.5);\n      var context = this.contexts.hovers; // Clearing\n\n      context.clearRect(0, 0, this.width, this.height); // Rendering\n\n      var render = function render(node) {\n        var data = _this5.nodeDataCache[node];\n\n        var _camera$graphToViewpo = camera.graphToViewport(_this5, data.x, data.y),\n            x = _camera$graphToViewpo.x,\n            y = _camera$graphToViewpo.y;\n\n        var size = data.size / sizeRatio;\n\n        _this5.settings.hoverRenderer(context, {\n          key: node,\n          label: data.label,\n          color: data.color,\n          size: size,\n          x: x,\n          y: y\n        }, _this5.settings);\n      };\n\n      if (this.hoveredNode) render(this.hoveredNode);\n      this.highlightedNodes.forEach(render);\n    }\n    /**\n     * Method used to schedule a render.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this6 = this;\n\n      // A frame is already scheduled\n      if (this.renderFrame) return this; // Let's schedule a frame\n\n      this.renderFrame = requestAnimationFrame(function () {\n        // Do we need to process data?\n        if (_this6.needToProcess) {\n          _this6.process();\n        } else if (_this6.needToSoftProcess) {\n          _this6.process(true);\n        } // Resetting state\n\n\n        _this6.renderFrame = null;\n        _this6.needToProcess = false;\n        _this6.needToSoftProcess = false; // Rendering\n\n        _this6.render();\n      });\n    }\n    /**\n     * Method used to schedule a hover render.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this7 = this;\n\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return this;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this7.renderHighlightedNodesFrame = null; // Rendering\n\n        _this7.renderHighlightedNodes();\n\n        _this7.renderEdgeLabels();\n      });\n    }\n    /**\n     * Method used to manually refresh.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.needToSoftProcess = true;\n      this.scheduleRender();\n      return this;\n    }\n    /**\n     * Method used to highlight a node.\n     *\n     * @param  {string} key - The node's key.\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"highlightNode\",\n    value: function highlightNode(key) {\n      // TODO: check the existence of the node\n      // TODO: coerce?\n      this.highlightedNodes.add(key); // Rendering\n\n      this.scheduleHighlightedNodesRender();\n      return this;\n    }\n    /**\n     * Method used to unhighlight a node.\n     *\n     * @param  {string} key - The node's key.\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"unhighlightNode\",\n    value: function unhighlightNode(key) {\n      // TODO: check the existence of the node\n      // TODO: coerce?\n      this.highlightedNodes[\"delete\"](key); // Rendering\n\n      this.scheduleHighlightedNodesRender();\n      return this;\n    }\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      var graph = this.graph; // Releasing camera handlers\n\n      this.camera.removeListener('updated', this.listeners.camera); // Releasing DOM events & captors\n\n      window.removeEventListener('resize', this.listeners.handleResize);\n      this.captors.mouse.kill(); // Releasing graph handlers\n\n      graph.removeListener('nodeAdded', this.listeners.addNodeGraphUpdate);\n      graph.removeListener('nodeDropped', this.listeners.graphUpdate);\n      graph.removeListener('nodeAttributesUpdated', this.listeners.softGraphUpdate);\n      graph.removeListener('edgeAdded', this.listeners.addEdgeGraphUpdate);\n      graph.removeListener('nodeDropped', this.listeners.graphUpdate);\n      graph.removeListener('edgeAttributesUpdated', this.listeners.softGraphUpdate);\n      graph.removeListener('cleared', this.listeners.graphUpdate); // Releasing cache & state\n\n      this.quadtree = null;\n      this.nodeDataCache = null;\n      this.edgeDataCache = null;\n      this.highlightedNodes = null;\n      this.previousVisibleNodes = null;\n      this.displayedLabels = null; // Clearing frames\n\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      } // Destroying canvases\n\n\n      var container = this.container;\n\n      while (container.firstChild) {\n        container.removeChild(container.firstChild);\n      }\n    }\n  }]);\n\n  return WebGLRenderer;\n}(_renderer[\"default\"]);\n\nexports[\"default\"] = WebGLRenderer;\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/index.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/matrices.js":
/*!********************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/matrices.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.identity = identity;\nexports.scale = scale;\nexports.rotate = rotate;\nexports.translate = translate;\nexports.multiply = multiply;\n\n/**\n * Sigma.js WebGL Matrices Helpers\n * ================================\n *\n * Matrices-related helper functions used by sigma's WebGL renderer.\n */\nfunction identity() {\n  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);\n} // TODO: optimize\n\n\nfunction scale(m, x, y) {\n  m[0] = x;\n  m[4] = arguments.length > 2 ? y : x;\n  return m;\n}\n\nfunction rotate(m, r) {\n  var s = Math.sin(r),\n      c = Math.cos(r);\n  m[0] = c;\n  m[1] = s;\n  m[3] = -s;\n  m[4] = c;\n  return m;\n}\n\nfunction translate(m, x, y) {\n  m[6] = x;\n  m[7] = y;\n  return m;\n}\n\nfunction multiply(a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return a;\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/matrices.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/programs/arrow.js":
/*!**************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/programs/arrow.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = _interopRequireDefault(__webpack_require__(/*! ./program */ \"./node_modules/sigma/renderers/webgl/programs/program.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/sigma/renderers/webgl/utils.js\");\n\nvar _arrowVert = _interopRequireDefault(__webpack_require__(/*! ../shaders/arrow.vert.glsl */ \"./node_modules/sigma/renderers/webgl/shaders/arrow.vert.glsl\"));\n\nvar _arrowFrag = _interopRequireDefault(__webpack_require__(/*! ../shaders/arrow.frag.glsl */ \"./node_modules/sigma/renderers/webgl/shaders/arrow.frag.glsl\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar POINTS = 3,\n    ATTRIBUTES = 10,\n    STRIDE = POINTS * ATTRIBUTES;\n\nvar ArrowProgram =\n/*#__PURE__*/\nfunction (_Program) {\n  _inherits(ArrowProgram, _Program);\n\n  function ArrowProgram(gl) {\n    var _this;\n\n    _classCallCheck(this, ArrowProgram);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ArrowProgram).call(this, gl, _arrowVert[\"default\"], _arrowFrag[\"default\"])); // Binding context\n\n    _this.gl = gl; // Array data\n\n    _this.array = null; // Initializing buffers\n\n    _this.buffer = gl.createBuffer(); // Locations\n\n    _this.positionLocation = gl.getAttribLocation(_this.program, 'a_position');\n    _this.normalLocation = gl.getAttribLocation(_this.program, 'a_normal');\n    _this.thicknessLocation = gl.getAttribLocation(_this.program, 'a_thickness');\n    _this.radiusLocation = gl.getAttribLocation(_this.program, 'a_radius');\n    _this.colorLocation = gl.getAttribLocation(_this.program, 'a_color');\n    _this.barycentricLocation = gl.getAttribLocation(_this.program, 'a_barycentric');\n    _this.resolutionLocation = gl.getUniformLocation(_this.program, 'u_resolution');\n    _this.ratioLocation = gl.getUniformLocation(_this.program, 'u_ratio');\n    _this.matrixLocation = gl.getUniformLocation(_this.program, 'u_matrix');\n    _this.scaleLocation = gl.getUniformLocation(_this.program, 'u_scale');\n\n    _this.bind();\n\n    return _this;\n  }\n\n  _createClass(ArrowProgram, [{\n    key: \"bind\",\n    value: function bind() {\n      var gl = this.gl;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer); // Bindings\n\n      gl.enableVertexAttribArray(this.positionLocation);\n      gl.enableVertexAttribArray(this.normalLocation);\n      gl.enableVertexAttribArray(this.thicknessLocation);\n      gl.enableVertexAttribArray(this.radiusLocation);\n      gl.enableVertexAttribArray(this.colorLocation);\n      gl.enableVertexAttribArray(this.barycentricLocation);\n      gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(this.thicknessLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n      gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n      gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24); // TODO: maybe we can optimize here by packing this in a bit mask\n\n      gl.vertexAttribPointer(this.barycentricLocation, 3, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 28);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(capacity) {\n      this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);\n    }\n  }, {\n    key: \"process\",\n    value: function process(sourceData, targetData, data, offset) {\n      if (sourceData.hidden || targetData.hidden || data.hidden) {\n        for (var _i = offset * STRIDE, l = _i + STRIDE; _i < l; _i++) {\n          this.array[_i] = 0;\n        }\n\n        return;\n      }\n\n      var thickness = Math.max((data.size || 1) * 2.5, 5),\n          radius = targetData.size || 1,\n          x1 = sourceData.x,\n          y1 = sourceData.y,\n          x2 = targetData.x,\n          y2 = targetData.y,\n          color = (0, _utils.floatColor)(data.color); // Computing normals\n\n      var dx = x2 - x1,\n          dy = y2 - y1;\n      var len = dx * dx + dy * dy,\n          n1 = 0,\n          n2 = 0;\n\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len;\n        n2 = dx * len;\n      }\n\n      var i = POINTS * ATTRIBUTES * offset;\n      var array = this.array; // First point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = radius;\n      array[i++] = color;\n      array[i++] = 1;\n      array[i++] = 0;\n      array[i++] = 0; // Second point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = radius;\n      array[i++] = color;\n      array[i++] = 0;\n      array[i++] = 1;\n      array[i++] = 0; // Third point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = radius;\n      array[i++] = color;\n      array[i++] = 0;\n      array[i++] = 0;\n      array[i] = 1;\n    }\n  }, {\n    key: \"bufferData\",\n    value: function bufferData() {\n      var gl = this.gl; // Vertices data\n\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      var gl = this.gl;\n      var program = this.program;\n      gl.useProgram(program); // Binding uniforms\n\n      gl.uniform2f(this.resolutionLocation, params.width, params.height);\n      gl.uniform1f(this.ratioLocation, params.ratio);\n      gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n      gl.uniform1f(this.scaleLocation, params.scalingRatio); // Drawing:\n\n      gl.drawArrays(gl.TRIANGLES, 0, this.array.length / ATTRIBUTES);\n    }\n  }]);\n\n  return ArrowProgram;\n}(_program[\"default\"]);\n\nexports[\"default\"] = ArrowProgram;\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/programs/arrow.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/programs/edge.arrow.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/programs/edge.arrow.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = __webpack_require__(/*! ./program */ \"./node_modules/sigma/renderers/webgl/programs/program.js\");\n\nvar _arrow = _interopRequireDefault(__webpack_require__(/*! ./arrow */ \"./node_modules/sigma/renderers/webgl/programs/arrow.js\"));\n\nvar _edge = _interopRequireDefault(__webpack_require__(/*! ./edge.clamped */ \"./node_modules/sigma/renderers/webgl/programs/edge.clamped.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Sigma.js WebGL Renderer Edge Arrow Program\n * ===========================================\n *\n * Compound program rendering edges as an arrow from the source to the target.\n */\nvar program = (0, _program.createCompoundProgram)([_edge[\"default\"], _arrow[\"default\"]]);\nvar _default = program;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/programs/edge.arrow.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/programs/edge.clamped.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/programs/edge.clamped.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = _interopRequireDefault(__webpack_require__(/*! ./program */ \"./node_modules/sigma/renderers/webgl/programs/program.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/sigma/renderers/webgl/utils.js\");\n\nvar _edgeClampedVert = _interopRequireDefault(__webpack_require__(/*! ../shaders/edge.clamped.vert.glsl */ \"./node_modules/sigma/renderers/webgl/shaders/edge.clamped.vert.glsl\"));\n\nvar _edgeFrag = _interopRequireDefault(__webpack_require__(/*! ../shaders/edge.frag.glsl */ \"./node_modules/sigma/renderers/webgl/shaders/edge.frag.glsl\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar POINTS = 4,\n    ATTRIBUTES = 7,\n    STRIDE = POINTS * ATTRIBUTES;\n\nvar EdgeClampedProgram =\n/*#__PURE__*/\nfunction (_Program) {\n  _inherits(EdgeClampedProgram, _Program);\n\n  function EdgeClampedProgram(gl) {\n    var _this;\n\n    _classCallCheck(this, EdgeClampedProgram);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EdgeClampedProgram).call(this, gl, _edgeClampedVert[\"default\"], _edgeFrag[\"default\"])); // Binding context\n\n    _this.gl = gl; // Array data\n\n    _this.array = null;\n    _this.indicesArray = null; // Initializing buffers\n\n    _this.buffer = gl.createBuffer();\n    _this.indicesBuffer = gl.createBuffer(); // Locations\n\n    _this.positionLocation = gl.getAttribLocation(_this.program, 'a_position');\n    _this.normalLocation = gl.getAttribLocation(_this.program, 'a_normal');\n    _this.thicknessLocation = gl.getAttribLocation(_this.program, 'a_thickness');\n    _this.colorLocation = gl.getAttribLocation(_this.program, 'a_color');\n    _this.radiusLocation = gl.getAttribLocation(_this.program, 'a_radius');\n    _this.resolutionLocation = gl.getUniformLocation(_this.program, 'u_resolution');\n    _this.ratioLocation = gl.getUniformLocation(_this.program, 'u_ratio');\n    _this.matrixLocation = gl.getUniformLocation(_this.program, 'u_matrix');\n    _this.scaleLocation = gl.getUniformLocation(_this.program, 'u_scale');\n\n    _this.bind(); // Enabling the OES_element_index_uint extension\n    // NOTE: on older GPUs, this means that really large graphs won't\n    // have all their edges rendered. But it seems that the\n    // `OES_element_index_uint` is quite everywhere so we'll handle\n    // the potential issue if it really arises.\n    // NOTE: when using webgl2, the extension is enabled by default\n\n\n    _this.canUse32BitsIndices = (0, _utils.canUse32BitsIndices)(gl);\n    _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;\n    _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;\n    return _this;\n  }\n\n  _createClass(EdgeClampedProgram, [{\n    key: \"bind\",\n    value: function bind() {\n      var gl = this.gl;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer); // Bindings\n\n      gl.enableVertexAttribArray(this.positionLocation);\n      gl.enableVertexAttribArray(this.normalLocation);\n      gl.enableVertexAttribArray(this.thicknessLocation);\n      gl.enableVertexAttribArray(this.colorLocation);\n      gl.enableVertexAttribArray(this.radiusLocation);\n      gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(this.thicknessLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n      gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n      gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(capacity) {\n      this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);\n    }\n  }, {\n    key: \"process\",\n    value: function process(sourceData, targetData, data, offset) {\n      if (sourceData.hidden || targetData.hidden || data.hidden) {\n        for (var _i = offset * STRIDE, l = _i + STRIDE; _i < l; _i++) {\n          this.array[_i] = 0;\n        }\n\n        return;\n      }\n\n      var thickness = data.size || 1,\n          x1 = sourceData.x,\n          y1 = sourceData.y,\n          x2 = targetData.x,\n          y2 = targetData.y,\n          radius = targetData.size || 1,\n          color = (0, _utils.floatColor)(data.color); // Computing normals\n\n      var dx = x2 - x1,\n          dy = y2 - y1;\n      var len = dx * dx + dy * dy,\n          n1 = 0,\n          n2 = 0;\n\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len;\n        n2 = dx * len;\n      }\n\n      var i = POINTS * ATTRIBUTES * offset;\n      var array = this.array; // First point\n\n      array[i++] = x1;\n      array[i++] = y1;\n      array[i++] = n1;\n      array[i++] = n2;\n      array[i++] = thickness;\n      array[i++] = color;\n      array[i++] = 0; // First point flipped\n\n      array[i++] = x1;\n      array[i++] = y1;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = color;\n      array[i++] = 0; // Second point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = n1;\n      array[i++] = n2;\n      array[i++] = thickness;\n      array[i++] = color;\n      array[i++] = radius; // Second point flipped\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = color;\n      array[i] = -radius;\n    }\n  }, {\n    key: \"computeIndices\",\n    value: function computeIndices() {\n      var l = this.array.length / ATTRIBUTES;\n      var size = l + l / 2;\n      var indices = new this.IndicesArray(size);\n\n      for (var i = 0, c = 0; i < l; i += 4) {\n        indices[c++] = i;\n        indices[c++] = i + 1;\n        indices[c++] = i + 2;\n        indices[c++] = i + 2;\n        indices[c++] = i + 1;\n        indices[c++] = i + 3;\n      }\n\n      this.indicesArray = indices;\n    }\n  }, {\n    key: \"bufferData\",\n    value: function bufferData() {\n      var gl = this.gl; // Vertices data\n\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW); // Indices data\n\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      var gl = this.gl;\n      var program = this.program;\n      gl.useProgram(program); // Binding uniforms\n      // TODO: precise the uniform names\n\n      gl.uniform2f(this.resolutionLocation, params.width, params.height);\n      gl.uniform1f(this.ratioLocation, // 1 / Math.pow(params.ratio, params.edgesPowRatio)\n      params.ratio);\n      gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n      gl.uniform1f(this.scaleLocation, params.scalingRatio); // Drawing:\n\n      gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);\n    }\n  }]);\n\n  return EdgeClampedProgram;\n}(_program[\"default\"]);\n\nexports[\"default\"] = EdgeClampedProgram;\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/programs/edge.clamped.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/programs/edge.js":
/*!*************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/programs/edge.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = _interopRequireDefault(__webpack_require__(/*! ./program */ \"./node_modules/sigma/renderers/webgl/programs/program.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/sigma/renderers/webgl/utils.js\");\n\nvar _edgeVert = _interopRequireDefault(__webpack_require__(/*! ../shaders/edge.vert.glsl */ \"./node_modules/sigma/renderers/webgl/shaders/edge.vert.glsl\"));\n\nvar _edgeFrag = _interopRequireDefault(__webpack_require__(/*! ../shaders/edge.frag.glsl */ \"./node_modules/sigma/renderers/webgl/shaders/edge.frag.glsl\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar POINTS = 4,\n    ATTRIBUTES = 6,\n    STRIDE = POINTS * ATTRIBUTES;\n\nvar EdgeProgram =\n/*#__PURE__*/\nfunction (_Program) {\n  _inherits(EdgeProgram, _Program);\n\n  function EdgeProgram(gl) {\n    var _this;\n\n    _classCallCheck(this, EdgeProgram);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EdgeProgram).call(this, gl, _edgeVert[\"default\"], _edgeFrag[\"default\"])); // Binding context\n\n    _this.gl = gl; // Array data\n\n    _this.array = null;\n    _this.indicesArray = null; // Initializing buffers\n\n    _this.buffer = gl.createBuffer();\n    _this.indicesBuffer = gl.createBuffer(); // Locations\n\n    _this.positionLocation = gl.getAttribLocation(_this.program, 'a_position');\n    _this.normalLocation = gl.getAttribLocation(_this.program, 'a_normal');\n    _this.thicknessLocation = gl.getAttribLocation(_this.program, 'a_thickness');\n    _this.colorLocation = gl.getAttribLocation(_this.program, 'a_color');\n    _this.resolutionLocation = gl.getUniformLocation(_this.program, 'u_resolution');\n    _this.ratioLocation = gl.getUniformLocation(_this.program, 'u_ratio');\n    _this.matrixLocation = gl.getUniformLocation(_this.program, 'u_matrix');\n    _this.scaleLocation = gl.getUniformLocation(_this.program, 'u_scale');\n\n    _this.bind(); // Enabling the OES_element_index_uint extension\n    // NOTE: on older GPUs, this means that really large graphs won't\n    // have all their edges rendered. But it seems that the\n    // `OES_element_index_uint` is quite everywhere so we'll handle\n    // the potential issue if it really arises.\n    // NOTE: when using webgl2, the extension is enabled by default\n\n\n    _this.canUse32BitsIndices = (0, _utils.canUse32BitsIndices)(gl);\n    _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;\n    _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;\n    return _this;\n  }\n\n  _createClass(EdgeProgram, [{\n    key: \"bind\",\n    value: function bind() {\n      var gl = this.gl;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer); // Bindings\n\n      gl.enableVertexAttribArray(this.positionLocation);\n      gl.enableVertexAttribArray(this.normalLocation);\n      gl.enableVertexAttribArray(this.thicknessLocation);\n      gl.enableVertexAttribArray(this.colorLocation);\n      gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(this.thicknessLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n      gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(capacity) {\n      this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);\n    }\n  }, {\n    key: \"process\",\n    value: function process(sourceData, targetData, data, offset) {\n      if (sourceData.hidden || targetData.hidden || data.hidden) {\n        for (var _i = offset * STRIDE, l = _i + STRIDE; _i < l; _i++) {\n          this.array[_i] = 0;\n        }\n\n        return;\n      }\n\n      var thickness = data.size || 1,\n          x1 = sourceData.x,\n          y1 = sourceData.y,\n          x2 = targetData.x,\n          y2 = targetData.y,\n          color = (0, _utils.floatColor)(data.color); // Computing normals\n\n      var dx = x2 - x1,\n          dy = y2 - y1;\n      var len = dx * dx + dy * dy,\n          n1 = 0,\n          n2 = 0;\n\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len;\n        n2 = dx * len;\n      }\n\n      var i = POINTS * ATTRIBUTES * offset;\n      var array = this.array; // First point\n\n      array[i++] = x1;\n      array[i++] = y1;\n      array[i++] = n1;\n      array[i++] = n2;\n      array[i++] = thickness;\n      array[i++] = color; // First point flipped\n\n      array[i++] = x1;\n      array[i++] = y1;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = color; // Second point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = n1;\n      array[i++] = n2;\n      array[i++] = thickness;\n      array[i++] = color; // Second point flipped\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i] = color;\n    }\n  }, {\n    key: \"computeIndices\",\n    value: function computeIndices() {\n      var l = this.array.length / ATTRIBUTES;\n      var size = l + l / 2;\n      var indices = new this.IndicesArray(size);\n\n      for (var i = 0, c = 0; i < l; i += 4) {\n        indices[c++] = i;\n        indices[c++] = i + 1;\n        indices[c++] = i + 2;\n        indices[c++] = i + 2;\n        indices[c++] = i + 1;\n        indices[c++] = i + 3;\n      }\n\n      this.indicesArray = indices;\n    }\n  }, {\n    key: \"bufferData\",\n    value: function bufferData() {\n      var gl = this.gl; // Vertices data\n\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW); // Indices data\n\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      var gl = this.gl;\n      var program = this.program;\n      gl.useProgram(program); // Binding uniforms\n      // TODO: precise the uniform names\n\n      gl.uniform2f(this.resolutionLocation, params.width, params.height);\n      gl.uniform1f(this.ratioLocation, // 1 / Math.pow(params.ratio, params.edgesPowRatio)\n      params.ratio);\n      gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n      gl.uniform1f(this.scaleLocation, params.scalingRatio); // Drawing:\n\n      gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);\n    }\n  }]);\n\n  return EdgeProgram;\n}(_program[\"default\"]);\n\nexports[\"default\"] = EdgeProgram;\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/programs/edge.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/programs/node.fast.js":
/*!******************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/programs/node.fast.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = _interopRequireDefault(__webpack_require__(/*! ./program */ \"./node_modules/sigma/renderers/webgl/programs/program.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/sigma/renderers/webgl/utils.js\");\n\nvar _nodeFastVert = _interopRequireDefault(__webpack_require__(/*! ../shaders/node.fast.vert.glsl */ \"./node_modules/sigma/renderers/webgl/shaders/node.fast.vert.glsl\"));\n\nvar _nodeFastFrag = _interopRequireDefault(__webpack_require__(/*! ../shaders/node.fast.frag.glsl */ \"./node_modules/sigma/renderers/webgl/shaders/node.fast.frag.glsl\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar POINTS = 1,\n    ATTRIBUTES = 4;\n\nvar NodeProgramFast =\n/*#__PURE__*/\nfunction (_Program) {\n  _inherits(NodeProgramFast, _Program);\n\n  function NodeProgramFast(gl) {\n    var _this;\n\n    _classCallCheck(this, NodeProgramFast);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeProgramFast).call(this, gl, _nodeFastVert[\"default\"], _nodeFastFrag[\"default\"])); // Binding context\n\n    _this.gl = gl; // Array data\n\n    _this.array = null; // Initializing buffers\n\n    _this.buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, _this.buffer);\n    var program = _this.program; // Locations\n\n    _this.positionLocation = gl.getAttribLocation(program, 'a_position');\n    _this.sizeLocation = gl.getAttribLocation(program, 'a_size');\n    _this.colorLocation = gl.getAttribLocation(program, 'a_color');\n    _this.matrixLocation = gl.getUniformLocation(program, 'u_matrix');\n    _this.ratioLocation = gl.getUniformLocation(program, 'u_ratio');\n    _this.scaleLocation = gl.getUniformLocation(program, 'u_scale'); // Bindings\n\n    gl.enableVertexAttribArray(_this.positionLocation);\n    gl.enableVertexAttribArray(_this.sizeLocation);\n    gl.enableVertexAttribArray(_this.colorLocation);\n    gl.vertexAttribPointer(_this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(_this.sizeLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n    gl.vertexAttribPointer(_this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 12);\n    return _this;\n  }\n\n  _createClass(NodeProgramFast, [{\n    key: \"allocate\",\n    value: function allocate(capacity) {\n      this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);\n    }\n  }, {\n    key: \"process\",\n    value: function process(data, offset) {\n      var color = (0, _utils.floatColor)(data.color);\n      var i = offset * POINTS * ATTRIBUTES;\n      var array = this.array;\n\n      if (data.hidden) {\n        array[i++] = 0;\n        array[i++] = 0;\n        array[i++] = 0;\n        array[i++] = 0;\n        return;\n      }\n\n      array[i++] = data.x;\n      array[i++] = data.y;\n      array[i++] = data.size;\n      array[i] = color;\n    }\n  }, {\n    key: \"bufferData\",\n    value: function bufferData() {\n      var gl = this.gl;\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      var gl = this.gl;\n      var program = this.program;\n      gl.useProgram(program);\n      gl.uniform1f(this.ratioLocation, 1 / Math.pow(params.ratio, params.nodesPowRatio));\n      gl.uniform1f(this.scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n      gl.drawArrays(gl.POINTS, 0, this.array.length / ATTRIBUTES);\n    }\n  }]);\n\n  return NodeProgramFast;\n}(_program[\"default\"]);\n\nexports[\"default\"] = NodeProgramFast;\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/programs/node.fast.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/programs/program.js":
/*!****************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/programs/program.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCompoundProgram = createCompoundProgram;\nexports[\"default\"] = void 0;\n\nvar _utils = __webpack_require__(/*! ../shaders/utils */ \"./node_modules/sigma/renderers/webgl/shaders/utils.js\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Program class.\n *\n * @constructor\n */\nvar Program =\n/*#__PURE__*/\nfunction () {\n  function Program(gl, vertexShaderSource, fragmentShaderSource) {\n    _classCallCheck(this, Program);\n\n    this.vertexShaderSource = vertexShaderSource;\n    this.fragmentShaderSource = fragmentShaderSource;\n    this.load(gl);\n  }\n  /**\n   * Method used to load the program into a webgl context.\n   *\n   * @param  {WebGLContext} gl - The WebGL context.\n   * @return {WebGLProgram}\n   */\n\n\n  _createClass(Program, [{\n    key: \"load\",\n    value: function load(gl) {\n      this.vertexShader = (0, _utils.loadVertexShader)(gl, this.vertexShaderSource);\n      this.fragmentShader = (0, _utils.loadFragmentShader)(gl, this.fragmentShaderSource);\n      this.program = (0, _utils.loadProgram)(gl, [this.vertexShader, this.fragmentShader]);\n      return this.program;\n    }\n  }]);\n\n  return Program;\n}();\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @return {function}\n */\n// TODO: maybe those should handle their own canvases\n\n\nexports[\"default\"] = Program;\n\nfunction createCompoundProgram(programClasses) {\n  return (\n    /*#__PURE__*/\n    function () {\n      function CompoundProgram(gl) {\n        _classCallCheck(this, CompoundProgram);\n\n        this.programs = programClasses.map(function (ProgramClass) {\n          return new ProgramClass(gl);\n        });\n      }\n\n      _createClass(CompoundProgram, [{\n        key: \"allocate\",\n        value: function allocate(capacity) {\n          this.programs.forEach(function (program) {\n            return program.allocate(capacity);\n          });\n        }\n      }, {\n        key: \"process\",\n        value: function process() {\n          var args = arguments;\n          this.programs.forEach(function (program) {\n            return program.process.apply(program, _toConsumableArray(args));\n          });\n        }\n      }, {\n        key: \"computeIndices\",\n        value: function computeIndices() {\n          this.programs.forEach(function (program) {\n            if (typeof program.computeIndices === 'function') program.computeIndices();\n          });\n        }\n      }, {\n        key: \"bufferData\",\n        value: function bufferData() {\n          this.programs.forEach(function (program) {\n            return program.bufferData();\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var args = arguments;\n          this.programs.forEach(function (program) {\n            program.bind();\n            program.bufferData();\n            program.render.apply(program, _toConsumableArray(args));\n          });\n        }\n      }]);\n\n      return CompoundProgram;\n    }()\n  );\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/programs/program.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/settings.js":
/*!********************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/settings.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateWebglRendererSettings = validateWebglRendererSettings;\nexports.WEBGL_RENDERER_DEFAULT_SETTINGS = void 0;\n\nvar _label = _interopRequireDefault(__webpack_require__(/*! ../canvas/components/label */ \"./node_modules/sigma/renderers/canvas/components/label.js\"));\n\nvar _hover = _interopRequireDefault(__webpack_require__(/*! ../canvas/components/hover */ \"./node_modules/sigma/renderers/canvas/components/hover.js\"));\n\nvar _edgeLabel = _interopRequireDefault(__webpack_require__(/*! ../canvas/components/edge-label */ \"./node_modules/sigma/renderers/canvas/components/edge-label.js\"));\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./programs/node.fast */ \"./node_modules/sigma/renderers/webgl/programs/node.fast.js\"));\n\nvar _edge = _interopRequireDefault(__webpack_require__(/*! ./programs/edge */ \"./node_modules/sigma/renderers/webgl/programs/edge.js\"));\n\nvar _edge2 = _interopRequireDefault(__webpack_require__(/*! ./programs/edge.arrow */ \"./node_modules/sigma/renderers/webgl/programs/edge.arrow.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Sigma.js WebGL Renderer Settings\n * =================================\n *\n * The list of settings for the WebGL renderer and some handy functions.\n */\nfunction validateWebglRendererSettings(settings) {\n  // Label grid cell\n  if (settings.labelGrid && settings.labelGrid.cell && _typeof(settings.labelGrid.cell) === 'object' && (!settings.labelGrid.cell.width || !settings.labelGrid.cell.height)) {\n    throw new Error('sigma/renderers/webgl/settings: invalid `labelGrid.cell`. Expecting {width, height}.');\n  }\n}\n\nvar WEBGL_RENDERER_DEFAULT_SETTINGS = {\n  // Performance\n  hideEdgesOnMove: false,\n  hideLabelsOnMove: false,\n  renderLabels: true,\n  renderEdgeLabels: false,\n  // Component rendering\n  defaultNodeColor: '#999',\n  defaultNodeType: 'circle',\n  defaultEdgeColor: '#ccc',\n  defaultEdgeType: 'line',\n  labelFont: 'Arial',\n  labelSize: 14,\n  labelWeight: 'normal',\n  edgeLabelFont: 'Arial',\n  edgeLabelSize: 14,\n  edgeLabelWeight: 'normal',\n  // Labels\n  labelGrid: {\n    cell: null,\n    renderedSizeThreshold: -Infinity\n  },\n  // Reducers\n  nodeReducer: null,\n  edgeReducer: null,\n  // Features\n  zIndex: false,\n  // Renderers\n  labelRenderer: _label[\"default\"],\n  hoverRenderer: _hover[\"default\"],\n  edgeLabelRenderer: _edgeLabel[\"default\"],\n  // Program classes\n  nodeProgramClasses: {\n    circle: _node[\"default\"]\n  },\n  edgeProgramClasses: {\n    arrow: _edge2[\"default\"],\n    line: _edge[\"default\"]\n  }\n};\nexports.WEBGL_RENDERER_DEFAULT_SETTINGS = WEBGL_RENDERER_DEFAULT_SETTINGS;\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/settings.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/shaders/arrow.frag.glsl":
/*!********************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/shaders/arrow.frag.glsl ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\n\\nvarying vec4 v_color;\\n// varying vec3 v_barycentric;\\n\\nvoid main(void) {\\n  // if (any(lessThan(v_barycentric, vec3(0.01))))\\n  //   discard;\\n  // else\\n    gl_FragColor = v_color;\\n}\\n\"\n\n/***/ })\n/******/ ]);\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/shaders/arrow.frag.glsl?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/shaders/arrow.vert.glsl":
/*!********************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/shaders/arrow.vert.glsl ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_thickness;\\nattribute float a_radius;\\nattribute vec4 a_color;\\nattribute vec3 a_barycentric;\\n\\nuniform vec2 u_resolution;\\nuniform float u_ratio;\\nuniform mat3 u_matrix;\\nuniform float u_scale;\\n\\nvarying vec4 v_color;\\n// varying vec3 v_barycentric;\\n\\nconst float arrow_ratio = 0.66;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  float pow_ratio = 1.0 / pow(u_ratio, 0.5) * 2.0;\\n  float radius = (a_radius - 1.0) * pow_ratio;\\n  float thickness = a_thickness * pow_ratio / u_scale;\\n  float width = arrow_ratio * thickness / 2.0;\\n\\n  vec2 delta = vec2(\\n      da * ((radius) * a_normal.y)\\n    + db * ((radius + thickness) * a_normal.y + width * a_normal.x)\\n    + dc * ((radius + thickness) * a_normal.y - width * a_normal.x),\\n\\n      da * (-(radius) * a_normal.x)\\n    + db * (-(radius + thickness) * a_normal.x + width * a_normal.y)\\n    + dc * (-(radius + thickness) * a_normal.x - width * a_normal.y)\\n  );\\n\\n  delta /= u_resolution;\\n\\n  // Scale from [[-1 1] [-1 1]] to the container:\\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\\n  position += delta;\\n\\n  // Applying\\n  gl_Position = vec4(position, 0, 1);\\n\\n  // v_barycentric = a_barycentric;\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\"\n\n/***/ })\n/******/ ]);\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/shaders/arrow.vert.glsl?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/shaders/edge.clamped.vert.glsl":
/*!***************************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/shaders/edge.clamped.vert.glsl ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 2:\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_thickness;\\nattribute vec4 a_color;\\nattribute float a_radius;\\n\\nuniform vec2 u_resolution;\\nuniform float u_ratio;\\nuniform mat3 u_matrix;\\nuniform float u_scale;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float min_thickness = 1.8;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n\\n  // Computing thickness in pixels\\n  float pow_ratio = 1.0 / pow(u_ratio, 0.5);\\n  float thickness = a_thickness * pow_ratio / u_scale;\\n\\n  // Min thickness for AA\\n  thickness = max(min_thickness, thickness);\\n\\n  // Arrow margin\\n  // NOTE: it seems we don't need a constant margin into the arrow\\n  float arrow_pow_ratio = pow_ratio * 2.0;\\n  float radius = abs(a_radius) * arrow_pow_ratio;\\n  float arrow_thickness = max(a_thickness * 2.5, 5.0) * arrow_pow_ratio / u_scale;\\n  float margin = radius + arrow_thickness - arrow_pow_ratio;\\n  float direction = sign(a_radius);\\n  vec2 pnormal = vec2(-direction * a_normal.y, direction * a_normal.x);\\n\\n  // Computing delta relative to viewport\\n  vec2 delta = (a_normal * thickness) / u_resolution;\\n  vec2 clamped = (pnormal * margin) / u_resolution;\\n\\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\\n  position += delta + clamped;\\n\\n  // Applying\\n  gl_Position = vec4(position, 0, 1);\\n\\n  v_normal = a_normal;\\n  v_thickness = thickness;\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\"\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/shaders/edge.clamped.vert.glsl?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/shaders/edge.frag.glsl":
/*!*******************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/shaders/edge.frag.glsl ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 5:\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float feather = 2.6;\\nconst vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float dist = length(v_normal) * v_thickness;\\n\\n  float t = smoothstep(\\n    v_thickness - feather,\\n    v_thickness,\\n    dist\\n  );\\n\\n  gl_FragColor = mix(v_color, color0, t);\\n}\\n\"\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/shaders/edge.frag.glsl?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/shaders/edge.vert.glsl":
/*!*******************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/shaders/edge.vert.glsl ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 10);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 10:\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_thickness;\\nattribute vec4 a_color;\\n\\nuniform vec2 u_resolution;\\nuniform float u_ratio;\\nuniform mat3 u_matrix;\\nuniform float u_scale;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float min_thickness = 1.8;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n\\n  // Computing thickness in pixels\\n  float pow_ratio = 1.0 / pow(u_ratio, 0.5);\\n  float thickness = a_thickness * pow_ratio / u_scale;\\n\\n  // Min thickness for AA\\n  thickness = max(min_thickness, thickness);\\n\\n  // Computing delta relative to viewport\\n  vec2 delta = (a_normal * thickness) / u_resolution;\\n\\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\\n  position += delta;\\n\\n  // Applying\\n  gl_Position = vec4(position, 0, 1);\\n\\n  v_normal = a_normal;\\n  v_thickness = thickness;\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\"\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/shaders/edge.vert.glsl?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/shaders/node.fast.frag.glsl":
/*!************************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/shaders/node.fast.frag.glsl ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 11);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 11:\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float radius = 0.5;\\n\\nvoid main(void) {\\n  vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);\\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\\n  float dist = radius - length(m);\\n\\n  float t = 0.0;\\n  if (dist > v_border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / v_border;\\n\\n  // gl_FragColor = mix(color0, v_color, t);\\n  gl_FragColor = mix(color0, v_color, t);\\n}\\n\"\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/shaders/node.fast.frag.glsl?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/shaders/node.fast.vert.glsl":
/*!************************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/shaders/node.fast.vert.glsl ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 12);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 12:\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute float a_size;\\nattribute vec4 a_color;\\n\\nuniform float u_ratio;\\nuniform float u_scale;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\\n\\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\"\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/shaders/node.fast.vert.glsl?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/shaders/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/shaders/utils.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadProgram = loadProgram;\nexports.loadFragmentShader = exports.loadVertexShader = void 0;\n\n/**\n * Sigma.js Shader Utils\n * ======================\n *\n * Code used to load sigma's shaders.\n */\n\n/**\n * Function used to load a shader.\n */\nfunction loadShader(type, gl, source) {\n  var glType = type === 'VERTEX' ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER; // Creating the shader\n\n  var shader = gl.createShader(glType); // Loading source\n\n  gl.shaderSource(shader, source); // Compiling the shader\n\n  gl.compileShader(shader); // Retrieving compilation status\n\n  var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS); // Throwing if something went awry\n\n  if (!successfullyCompiled) {\n    var infoLog = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(\"sigma/renderers/webgl/shaders/utils.loadShader: error while compiling the shader:\\n\".concat(infoLog, \"\\n\").concat(source));\n  }\n\n  return shader;\n}\n\nvar loadVertexShader = loadShader.bind(null, 'VERTEX'),\n    loadFragmentShader = loadShader.bind(null, 'FRAGMENT');\nexports.loadFragmentShader = loadFragmentShader;\nexports.loadVertexShader = loadVertexShader;\n\n/**\n * Function used to load a program.\n */\nfunction loadProgram(gl, shaders) {\n  var program = gl.createProgram();\n  var i, l; // Attaching the shaders\n\n  for (i = 0, l = shaders.length; i < l; i++) {\n    gl.attachShader(program, shaders[i]);\n  }\n\n  gl.linkProgram(program); // Checking status\n\n  var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error('sigma/renderers/webgl/shaders/utils.loadProgram: error while linking the program.');\n  }\n\n  return program;\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/shaders/utils.js?");

/***/ }),

/***/ "./node_modules/sigma/renderers/webgl/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/sigma/renderers/webgl/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.floatColor = floatColor;\nexports.matrixFromCamera = matrixFromCamera;\nexports.extractPixel = extractPixel;\nexports.canUse32BitsIndices = canUse32BitsIndices;\n\nvar _matrices = __webpack_require__(/*! ./matrices */ \"./node_modules/sigma/renderers/webgl/matrices.js\");\n\n/**\n * Sigma.js WebGL Renderer Utils\n * ==============================\n *\n * Miscelleanous helper functions used by sigma's WebGL renderer.\n */\n\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\nvar FLOAT_COLOR_CACHE = {};\nvar INT8 = new Int8Array(4);\nvar INT32 = new Int32Array(INT8.buffer, 0, 1);\nvar FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\nvar RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nvar RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\n\nfunction floatColor(val) {\n  // If the color is already computed, we yield it\n  if (typeof FLOAT_COLOR_CACHE[val] !== 'undefined') return FLOAT_COLOR_CACHE[val];\n  var r = 0,\n      g = 0,\n      b = 0,\n      a = 1; // Handling hexadecimal notation\n\n  if (val[0] === '#') {\n    if (val.length === 4) {\n      r = parseInt(val.charAt(1) + val.charAt(1), 16);\n      g = parseInt(val.charAt(2) + val.charAt(2), 16);\n      b = parseInt(val.charAt(3) + val.charAt(3), 16);\n    } else {\n      r = parseInt(val.charAt(1) + val.charAt(2), 16);\n      g = parseInt(val.charAt(3) + val.charAt(4), 16);\n      b = parseInt(val.charAt(5) + val.charAt(6), 16);\n    }\n  } // Handling rgb notation\n  else if (RGBA_TEST_REGEX.test(val)) {\n      var match = val.match(RGBA_EXTRACT_REGEX);\n      r = +match[1];\n      g = +match[2];\n      b = +match[3];\n      if (match[4]) a = +match[4];\n    }\n\n  a = a * 255 | 0;\n  var bits = (a << 24 | b << 16 | g << 8 | r) & 0xfeffffff;\n  INT32[0] = bits;\n  var color = FLOAT32[0];\n  FLOAT_COLOR_CACHE[val] = color;\n  return color;\n}\n/**\n * Function returning a matrix from the current state of the camera.\n */\n// TODO: it's possible to optimize this drastically!\n\n\nfunction matrixFromCamera(state, dimensions) {\n  var angle = state.angle,\n      ratio = state.ratio,\n      x = state.x,\n      y = state.y;\n  var width = dimensions.width,\n      height = dimensions.height;\n  var matrix = (0, _matrices.identity)();\n  var smallestDimension = Math.min(width, height);\n  var cameraCentering = (0, _matrices.translate)((0, _matrices.identity)(), -x, -y),\n      cameraScaling = (0, _matrices.scale)((0, _matrices.identity)(), 1 / ratio),\n      cameraRotation = (0, _matrices.rotate)((0, _matrices.identity)(), -angle),\n      viewportScaling = (0, _matrices.scale)((0, _matrices.identity)(), 2 * (smallestDimension / width), 2 * (smallestDimension / height)); // Logical order is reversed\n\n  (0, _matrices.multiply)(matrix, viewportScaling);\n  (0, _matrices.multiply)(matrix, cameraRotation);\n  (0, _matrices.multiply)(matrix, cameraScaling);\n  (0, _matrices.multiply)(matrix, cameraCentering);\n  return matrix;\n}\n/**\n * Function extracting the color at the given pixel.\n */\n\n\nfunction extractPixel(gl, x, y, array) {\n  var data = array || new Uint8Array(4);\n  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n  return data;\n}\n/**\n * Function used to know whether given webgl context can use 32 bits indices.\n */\n\n\nfunction canUse32BitsIndices(gl) {\n  var webgl2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n  return webgl2 || !!gl.getExtension('OES_element_index_uint');\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/renderers/webgl/utils.js?");

/***/ }),

/***/ "./node_modules/sigma/utils.js":
/*!*************************************!*\
  !*** ./node_modules/sigma/utils.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isPlainObject = isPlainObject;\nexports.assign = assign;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Sigma.js Utils\n * ===============\n *\n * Various helper functions & classes used throughout the library.\n */\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nfunction isPlainObject(value) {\n  return _typeof(value) === 'object' && value !== null && value.constructor === Object;\n}\n/**\n * Very simple recursive Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\n\n\nfunction assign(target) {\n  target = target || {};\n\n  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {\n    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    if (!o) continue;\n\n    for (var k in o) {\n      if (isPlainObject(o[k])) {\n        target[k] = assign(target[k], o[k]);\n      } else {\n        target[k] = o[k];\n      }\n    }\n  }\n\n  return target;\n}\n\n//# sourceURL=webpack:///./node_modules/sigma/utils.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/Filters/RangeFilter/index.ts":
/*!******************************************!*\
  !*** ./src/Filters/RangeFilter/index.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar RangeFilter = /** @class */ (function () {\n    function RangeFilter(props) {\n        this.props = __assign({}, props);\n        this.render = this.render.bind(this);\n        this.render();\n        this.values = this.values.bind(this);\n        this.getStatuses = this.getStatuses.bind(this);\n        this.getCheckboxes = this.getCheckboxes.bind(this);\n    }\n    RangeFilter.prototype.values = function () {\n        var ret = new Set(this.props.items.map(function (itm) { return itm.value; }));\n        // if (this.props.compareFunction){\n        //     ret = ret.sort(this.props.compareFunction);\n        // }\n        return ret;\n    };\n    RangeFilter.prototype.getCheckboxes = function () {\n        return this.props.el.getElementsByClassName(\"checkboxfilter-checkbox-input\");\n    };\n    RangeFilter.prototype.getStatuses = function () {\n        var ret = {};\n        Array.from(this.getCheckboxes()).forEach(function (el) {\n            ret[el.value] = el.checked;\n        });\n        return ret;\n    };\n    RangeFilter.prototype.render = function () {\n        var _this = this;\n        var el = this.props.el;\n        // Add a checkbox for each value\n        this.values().forEach(function (v, idx) {\n            var containerID = _this.props.id + \"-value-\" + idx;\n            var checkboxID = containerID + \"-checkbox\";\n            // <div class=\"checkboxfilter-container\" id=\"container\">\n            // <input type=\"checkbox\" id=\"vehicle1\" name=\"vehicle1\" value=\"Bike\">\n            // <label for=\"vehicle1\"> I have a bike</label>\n            // </div>\n            var containerEL = document.createElement(\"div\");\n            containerEL.classList.add(\"checkboxfilter-container\");\n            containerEL.id = containerID;\n            el.appendChild(containerEL);\n            var labelEl = document.createElement(\"label\");\n            labelEl.setAttribute(\"for\", checkboxID);\n            labelEl.innerText = String(v);\n            containerEL.appendChild(labelEl);\n            var checkboxEl = document.createElement(\"input\");\n            checkboxEl.classList.add(\"checkboxfilter-checkbox-input\");\n            checkboxEl.setAttribute(\"type\", \"checkbox\");\n            checkboxEl.setAttribute(\"name\", String(v));\n            checkboxEl.setAttribute(\"value\", String(v));\n            checkboxEl.checked = true;\n            checkboxEl.id = checkboxID;\n            containerEL.appendChild(checkboxEl);\n            checkboxEl.addEventListener(\"change\", function (evt) {\n                var event = new CustomEvent('filterUpdate', { detail: _this.getStatuses() });\n                el.dispatchEvent(event);\n            });\n        });\n        console.log(this.props.el);\n    };\n    return RangeFilter;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (RangeFilter);\n\n\n//# sourceURL=webpack:///./src/Filters/RangeFilter/index.ts?");

/***/ }),

/***/ "./src/Renderer/SigmaRenderer/index.ts":
/*!*********************************************!*\
  !*** ./src/Renderer/SigmaRenderer/index.ts ***!
  \*********************************************/
/*! exports provided: SigmaRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SigmaRenderer\", function() { return SigmaRenderer; });\n/* harmony import */ var sigma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sigma */ \"./node_modules/sigma/endpoint.js\");\n/* harmony import */ var sigma__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sigma__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var graphology__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphology */ \"./node_modules/graphology/dist/graphology.umd.min.js\");\n/* harmony import */ var graphology__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(graphology__WEBPACK_IMPORTED_MODULE_1__);\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n// import { MultiDirectedGraph } from 'graphology';\n\nvar SigmaRenderer = /** @class */ (function () {\n    function SigmaRenderer(props) {\n        this.props = __assign({}, props);\n        this.filteredEdges = {};\n        this.render = this.render.bind(this);\n        this.render();\n        this.addEventHandlers = this.addEventHandlers.bind(this);\n        this.addEventHandlers();\n        this.filterEdges = this.filterEdges.bind(this);\n    }\n    SigmaRenderer.prototype.filterEdges = function (selections) {\n        var _this = this;\n        this.filteredEdges = selections;\n        console.log(\"Filtering edges\", this.filteredEdges);\n        console.log(\"All edges\", this.edges);\n        var edgeIDs = Array.from(new Set(Object.keys(this.edges)));\n        console.log(\"Graph has \", this.graph.edges().length, \" edges\");\n        console.log(\"SigmaRenderer has \", edgeIDs.length, \" edges\");\n        var totalUpdated = 0;\n        edgeIDs.forEach(function (edgeID) {\n            var edgeData = _this.edges[edgeID];\n            // if (true || edgeID.includes(\"1313_\")){\n            //     console.log(\"Filter edges is looking at \", edgeID, edgeData)\n            // }\n            var selected = true;\n            var year = edgeData.year;\n            if (_this.filteredEdges[year] === false) {\n                selected = false;\n            }\n            _this.graph.setEdgeAttribute(edgeID, \"active\", selected);\n            totalUpdated += 1;\n            if (!selected) {\n                // console.log(\"set edge attribute\", this.graph.getEdgeAttribute(edgeID, \"active\"), edgeID);\n            }\n        });\n        console.log(\"Updated \", totalUpdated, \"edges\", this.graph.edges().length, Object.keys(this.edges).length);\n        this.graph.edges().forEach(function (edgeID) {\n            // console.log(edgeID, this.graph.getEdgeAttribute(edgeID, \"active\"))\n        });\n        this.renderer.refresh();\n    };\n    SigmaRenderer.prototype.addEventHandlers = function () {\n        var _this = this;\n        this.highlightedNodes = new Set();\n        this.highlightedEdges = new Set();\n        var nodeReducer = function (node, data) {\n            // if all of the neighbor-edges are inactive, disable\n            var active_count = 0;\n            var inactive_count = 0;\n            var neighbors = _this.graph.neighbors(node);\n            var hasAtLeastOneActiveEdge = false;\n            var nodeEdges = _this.graph.edges(node);\n            for (var idx in nodeEdges) {\n                var edge = nodeEdges[idx];\n                // const edgeAttributes = this.graph.getEdgeAttributes(edge)\n                // const edgeActive = this.graph.getEdgeAttribute(edge, \"active\")\n                var edgeActive = _this.graph.getEdgeAttribute(edge, \"active\");\n                // if (!(edge in this.edges)){\n                //     return { ...data, color: 'rgba(0,0,0,0)', zIndex: 0 }\n                //     this.graph.dropEdge(edge);\n                // }\n                if (edgeActive === true) {\n                    hasAtLeastOneActiveEdge = true;\n                    active_count++;\n                    // break;\n                }\n                else if (edgeActive === false) {\n                    inactive_count++;\n                }\n                else {\n                    console.warn(\"ERROR edge\", edge, edgeActive, _this.graph.getEdgeAttributes(edge));\n                }\n            }\n            // console.log(inactive_count, active_count)\n            if (!hasAtLeastOneActiveEdge) {\n                return __assign(__assign({}, data), { color: '#efefef', zIndex: 0 });\n            }\n            if (_this.highlightedNodes.has(node) && hasAtLeastOneActiveEdge)\n                return __assign(__assign({}, data), { color: '#f00', zIndex: 2 });\n            if (_this.highlightedNodes.has(node) && !hasAtLeastOneActiveEdge)\n                return __assign(__assign({}, data), { color: '#0f0', zIndex: 2 });\n            return __assign(__assign({}, data), { color: '#000', zIndex: 1 });\n            // return data;\n        };\n        var edgeReducer = function (edge, data) {\n            var edgeActive = _this.graph.getEdgeAttribute(edge, \"active\");\n            // if (data.active === false){\n            if (edgeActive == false) {\n                return __assign(__assign({}, data), { color: 'rgba(0,0,0,0)', zIndex: 1 });\n            }\n            if (_this.highlightedEdges.has(edge) && edgeActive == true)\n                return __assign(__assign({}, data), { color: '#f00', zIndex: 10 });\n            // if (this.highlightedEdges.has(edge) && edgeActive === false)\n            //     return { ...data, color: '#0f0', zIndex: 1 };\n            // if (edgeActive === false) {\n            //         console.log(\"edgeActive === false\", edge)\n            //         return { ...data, color: 'rgba(0,255,0,1)', zIndex: 0 };\n            //     }\n            return __assign(__assign({}, data), { color: '#efefef', zIndex: 1 });\n        };\n        this.renderer.on('clickNode', function (obj) {\n            console.log('Clicking:', obj.node, obj.captor);\n        });\n        this.renderer.on('clickStage', function () {\n            console.log('Clicking the stage.');\n        });\n        this.renderer.on('enterNode', function (evt) {\n            var node = evt.node;\n            _this.highlightedNodes = new Set(_this.graph.neighbors(node));\n            _this.highlightedNodes.add(node);\n            _this.highlightedEdges = new Set(_this.graph.edges(node));\n            _this.renderer.refresh();\n        });\n        this.renderer.on('leaveNode', function (evt) {\n            _this.highlightedNodes.clear();\n            _this.highlightedEdges.clear();\n            _this.renderer.refresh();\n        });\n        this.renderer.settings.nodeReducer = nodeReducer;\n        this.renderer.settings.edgeReducer = edgeReducer;\n    };\n    SigmaRenderer.prototype.render = function () {\n        var _this = this;\n        console.log(\"RENDER CALLED\");\n        this.node_dict = {};\n        // this.graph = erdosRenyi(graphology.UndirectedGraph, { order: this.props.nodes.length, probability: 0.2 });\n        this.graph = new graphology__WEBPACK_IMPORTED_MODULE_1__[\"UndirectedGraph\"]();\n        // this.graph.on('edgeAdded', function(evt:{key:string, source:string, target:string, attributes:{label:string}}) {\n        //     // console.log(\"edgeAdded\")//, evt.attributes.label, evt.source, evt.target)\n        //     // console.log(evt.key, evt.source, evt.target, this.graph.getEdgeAttributes(evt.key));\n        //   })\n        //this.graph.nodes().forEach((node: string, i: number) => {\n        this.props.nodes.forEach(function (full_node) {\n            //const full_node: GraphNode = this.props.nodes[i];\n            // graph.mergeNodeAttributes(node, full_node);\n            var node = _this.graph.addNode(full_node.id, __assign({}, full_node));\n            // this.graph.mergeNodeAttributes(node, { ...full_node })\n            // console.log(`Adding to full_node=${node}, i=${i} id=${full_node.id}`, full_node)\n            _this.node_dict[full_node.id] = node;\n        });\n        console.log(\"* Added all nodes\", this.graph.nodes());\n        this.edges = {};\n        // I'm not sure why we're starting with so many edges.\n        // Is it a property of ErdosRenyi that all the nodes are connected?\n        // console.log(\"There are \", this.graph.edges().length, \" edges \")\n        this.graph.clearEdges();\n        // console.log(\"Now there are \", this.graph.edges().length, \" edges \")\n        this.props.edges.forEach(function (edge, i) {\n            try {\n                var edgeID = _this.graph.addEdge(_this.node_dict[edge.from], _this.node_dict[edge.to], {\n                    active: true,\n                    label: edge.label\n                });\n                _this.graph.setEdgeAttribute(edgeID, \"active\", true);\n                _this.edges[edgeID] = edge;\n            }\n            catch (err) {\n                if (String(err).includes(\"already exists. If you really want\")) { }\n                else {\n                    console.error(err);\n                }\n                // don't add duplicate edges between two nodes. Use MultiUndirectGraph if you want that.\n            }\n        });\n        console.log(\"* Added all edges\", Object.keys(this.edges).length, Object.keys(this.edges).length, this.edges);\n        this.renderer = new sigma__WEBPACK_IMPORTED_MODULE_0__[\"WebGLRenderer\"](this.graph, this.props.el, {\n        // renderEdgeLabels: true\n        });\n    };\n    return SigmaRenderer;\n}());\n\n\n\n//# sourceURL=webpack:///./src/Renderer/SigmaRenderer/index.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _loadJSON__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadJSON */ \"./src/loadJSON.ts\");\n/* harmony import */ var _Filters_RangeFilter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Filters/RangeFilter */ \"./src/Filters/RangeFilter/index.ts\");\n/* harmony import */ var _Renderer_SigmaRenderer_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Renderer/SigmaRenderer/index */ \"./src/Renderer/SigmaRenderer/index.ts\");\n\n\n\nconsole.log(\"Hello!\");\n// Load JSON data\nPromise.all([\"./data/nodes.json\", \"./data/edges.json\"].map(_loadJSON__WEBPACK_IMPORTED_MODULE_0__[\"default\"]))\n    .then(function (results) {\n    var nodes = results[0], edges = results[1];\n    var filterYears = {};\n    // render graph\n    var graphEl = document.getElementById(\"graph\");\n    console.log(\"loaded \" + edges.length + \" edges and \" + nodes.length + \" nodes\");\n    console.log(graphEl);\n    var renderer;\n    function selectedNodesAndEdges() {\n        var goodNodes = [];\n        var goodEdges = [];\n        var addedNodeIds = [];\n        edges.forEach(function (e) {\n            if (filterYears[e.year] === false) {\n                return;\n            }\n            goodEdges.push(e);\n            var _loop_1 = function (n) {\n                if (n in addedNodeIds) {\n                    return \"continue\";\n                }\n                goodNodes.push(nodes.filter(function (x) { return x.id === n; })[0]);\n                addedNodeIds.push(n);\n            };\n            for (var n in [e.from, e.to]) {\n                _loop_1(n);\n            }\n        });\n        return {\n            nodes: goodNodes,\n            edges: goodEdges\n        };\n    }\n    function update() {\n        // const selected:{nodes:Array<SigmaRenderer.Node>, edges:Array<SigmaRenderer.Edge>} = selectedNodesAndEdges();\n        // const goodNodes = selected.nodes;\n        // const goodEdges = selected.edges;\n        // if (renderer){\n        // }\n        console.log(\"Rendering with \", nodes.length, \" nodes and \", edges.length, \" edges.\");\n        renderer = new _Renderer_SigmaRenderer_index__WEBPACK_IMPORTED_MODULE_2__[\"SigmaRenderer\"]({\n            nodes: nodes,\n            edges: edges,\n            el: graphEl\n        });\n    }\n    // render controls\n    var controlsEl = document.getElementById(\"controls\");\n    var filter = new _Filters_RangeFilter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        el: controlsEl,\n        items: edges.map(function (e, i) {\n            return {\n                id: String(i),\n                value: Number(e.year || 0)\n            };\n        }),\n        id: \"year-demo\"\n    });\n    // subscribe to filter events\n    controlsEl.addEventListener(\"filterUpdate\", function (evt) {\n        console.log(\"Received event details:\", evt.detail);\n        renderer.filterEdges(evt.detail);\n        // filterYears = evt.detail;\n        // update();\n    });\n    update();\n});\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/loadJSON.ts":
/*!*************************!*\
  !*** ./src/loadJSON.ts ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return loadJSON; });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nfunction loadJSON(url) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, fetch(url)\n                    .then(function (resp) { return resp.text(); })\n                    .then(function (text) {\n                    return text;\n                })\n                    .then(function (text) { return JSON.parse(text); })];\n        });\n    });\n}\n\n\n//# sourceURL=webpack:///./src/loadJSON.ts?");

/***/ })

/******/ });